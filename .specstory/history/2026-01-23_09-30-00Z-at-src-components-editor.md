<!-- Generated by SpecStory, Markdown v2.1.0 -->

# 2026-01-23 09:30:36Z

<!-- Codex CLI Session 019bea30-6a0d-74a0-a351-3d0a03742e11 (2026-01-23 09:30:36Z) -->

_**User (2026-01-23 09:30:36Z)**_

@src/components/editor/toolbar 修复toolbar的样式选定模式：

现在在toolbar中无法判断当前选定的文字是否已应用该样式，导致会重复应用当前样式。

---

_**Agent (gpt-5.2-codex 2026-01-23 09:30:39Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: 8b7d70
Wall time: 0.0522 seconds
Process exited with code 0
Original token count: 96
Output:
biome.json
CHANGELOG.md
CLAUDE.md
cliff.toml
create-tags.sh
dist
docs
favicon.png
ICON_MIGRATION.md
index.html
LICENSE
migrate-restmanager.sh
MIGRATION_GUIDE.md
MIGRATION_STATUS.md
netlify.toml
node_modules
package.json
pnpm-lock.yaml
polyfills
postcss.config.js
readme.md
REFACTOR_PLAN.md
release.sh
renovate.json
scripts
src
stats.html
tsconfig.json
uno.config.ts
vite.config.mts
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-23 09:30:43Z)**_

<think><details><summary>Thought Process</summary>
**Identifying need for AGENTS.md search**
</details></think>

_**Agent (gpt-5.2-codex 2026-01-23 09:30:43Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: a4bbba
Wall time: 0.0513 seconds
Process exited with code 1
Original token count: 0
Output:
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-23 09:30:47Z)**_

<think><details><summary>Thought Process</summary>
**Opening toolbar file for inspection**
</details></think>

_**Agent (gpt-5.2-codex 2026-01-23 09:30:48Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: 94037c
Wall time: 0.0506 seconds
Process exited with code 1
Original token count: 18
Output:
sed: src/components/editor/toolbar/index.vue: No such file or directory
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-23 09:30:51Z)**_

<think><details><summary>Thought Process</summary>
**Requesting path list**
</details></think>

_**Agent (gpt-5.2-codex 2026-01-23 09:30:51Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: 0f57b8
Wall time: 0.0517 seconds
Process exited with code 0
Original token count: 36
Output:
src/components/editor/toolbar/floating-toolbar.css
src/components/editor/toolbar/floating-toolbar.tsx
src/components/editor/toolbar/toolbar.tsx
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-23 09:30:56Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: 94db9d
Wall time: 0.0516 seconds
Process exited with code 0
Original token count: 1239
Output:
import {
  Bold,
  Code,
  FileCode,
  Heading,
  Italic,
  Link,
  List,
  ListOrdered,
  ListTodo,
  Minus,
  Quote,
  Redo2,
  Smile,
  Strikethrough,
  Undo2,
} from 'lucide-vue-next'
import { NPopover } from 'naive-ui'
import { defineComponent, ref } from 'vue'
import type { EditorView } from '@codemirror/view'
import type { Component, PropType } from 'vue'

import { redo, undo } from '@codemirror/commands'

import { EmojiPicker } from './emoji-picker'
import { commands } from './markdown-commands'

interface ToolbarButton {
  icon: Component
  title: string
  shortcut: string
  action: () => void
  divider?: boolean
}

export const MarkdownToolbar = defineComponent({
  name: 'MarkdownToolbar',
  props: {
    editorView: {
      type: Object as PropType<EditorView | undefined>,
      required: true,
    },
  },
  setup(props) {
    const emojiPickerVisible = ref(false)
    const emojiButtonRef = ref<HTMLElement>()

    const executeCommand = (commandFn: (view: EditorView) => boolean) => {
      if (props.editorView) {
        commandFn(props.editorView)
      }
    }

    const handleEmojiSelect = (emoji: string) => {
      if (props.editorView) {
        commands.emoji(props.editorView, emoji)
      }
      emojiPickerVisible.value = false
    }

    const buttons: ToolbarButton[] = [
      {
        icon: Smile,
        title: '插入表情',
        shortcut: 'Ctrl+E',
        action: () => {
          emojiPickerVisible.value = !emojiPickerVisible.value
        },
      },
      {
        icon: Heading,
        title: '标题',
        shortcut: 'Ctrl+H',
        action: () => executeCommand(commands.heading),
      },
      {
        icon: Bold,
        title: '粗体',
        shortcut: 'Ctrl+B',
        action: () => executeCommand(commands.bold),
      },
      {
        icon: Italic,
        title: '斜体',
        shortcut: 'Ctrl+I',
        action: () => executeCommand(commands.italic),
      },
      {
        icon: Strikethrough,
        title: '删除线',
        shortcut: 'Ctrl+D',
        action: () => executeCommand(commands.strikethrough),
      },
      {
        icon: Link,
        title: '链接',
        shortcut: 'Ctrl+K',
        action: () => executeCommand(commands.link),
        divider: true,
      },
      {
        icon: List,
        title: '无序列表',
        shortcut: 'Ctrl+L',
        action: () => executeCommand(commands.bulletList),
      },
      {
        icon: ListOrdered,
        title: '有序列表',
        shortcut: 'Ctrl+O',
        action: () => executeCommand(commands.orderedList),
      },
      {
        icon: ListTodo,
        title: '任务列表',
        shortcut: 'Ctrl+J',
        action: () => executeCommand(commands.taskList),
        divider: true,
      },
      {
        icon: Quote,
        title: '引用',
        shortcut: 'Ctrl+;',
        action: () => executeCommand(commands.quote),
      },
      {
        icon: Minus,
        title: '分隔线',
        shortcut: 'Ctrl+Shift+H',
        action: () => executeCommand(commands.horizontalRule),
      },
      {
        icon: FileCode,
        title: '代码块',
        shortcut: 'Ctrl+U',
        action: () => executeCommand(commands.codeBlock),
      },
      {
        icon: Code,
        title: '行内代码',
        shortcut: 'Ctrl+G',
        action: () => executeCommand(commands.inlineCode),
        divider: true,
      },
      {
        icon: Undo2,
        title: '撤销',
        shortcut: 'Ctrl+Z',
        action: () => {
          if (props.editorView) {
            props.editorView.focus()
            undo(props.editorView)
          }
        },
      },
      {
        icon: Redo2,
        title: '重做',
        shortcut: 'Ctrl+Y',
        action: () => {
          if (props.editorView) {
            props.editorView.focus()
            redo(props.editorView)
          }
        },
      },
    ]

    const ToolbarButtonComponent = defineComponent({
      props: {
        button: {
          type: Object as PropType<ToolbarButton>,
          required: true,
        },
        isEmojiButton: {
          type: Boolean,
          default: false,
        },
      },
      setup(buttonProps) {
        return () => (
          <NPopover
            trigger="hover"
            placement="bottom"
            delay={400}
            showArrow={false}
          >
            {{
              trigger: () => (
                <button
                  ref={buttonProps.isEmojiButton ? emojiButtonRef : undefined}
                  onClick={buttonProps.button.action}
                  class="toolbar-button inline-flex cursor-pointer items-center justify-center border-none bg-transparent outline-none"
                  aria-label={buttonProps.button.title}
                >
                  {/* @ts-ignore */}
                  <buttonProps.button.icon size={15} />
              
... (truncated)
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-23 09:30:58Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: 536cf2
Wall time: 0.0515 seconds
Process exited with code 0
Original token count: 600
Output:
              default: () => (
                <div class="px-2 py-1.5">
                  <div class="whitespace-nowrap text-xs">
                    {buttonProps.button.title}
                    <span class="ml-2 opacity-50">
                      {buttonProps.button.shortcut}
                    </span>
                  </div>
                </div>
              ),
            }}
          </NPopover>
        )
      },
    })

    return () => (
      <div class="markdown-toolbar flex items-center gap-2 py-2 pl-2 pr-4">
        {buttons.flatMap((button, index) => {
          const elements = [
            <ToolbarButtonComponent
              key={`btn-${index}`}
              button={button}
              isEmojiButton={index === 0}
            />,
          ]

          if (button.divider) {
            elements.push(
              <span
                key={`div-${index}`}
                class="inline-block h-4 w-px bg-neutral-300 opacity-50 dark:bg-neutral-600"
              />,
            )
          }

          return elements
        })}

        <NPopover
          show={emojiPickerVisible.value}
          onUpdateShow={(val) => (emojiPickerVisible.value = val)}
          trigger="manual"
          placement="bottom-start"
          x-placement="bottom-start"
          to={emojiButtonRef.value}
          style={{ padding: 0 }}
          onClickoutside={() => (emojiPickerVisible.value = false)}
        >
          {{
            trigger: () => (
              <span ref={emojiButtonRef} style={{ position: 'absolute' }} />
            ),
            default: () => <EmojiPicker onSelect={handleEmojiSelect} />,
          }}
        </NPopover>

        <style>
          {`
          .markdown-toolbar {
            background: transparent;
          }
          .markdown-toolbar .toolbar-button {
            padding: 6px;
            border-radius: 6px;
            transition: all 0.2s ease;
            opacity: 0.6;
          }
          .markdown-toolbar .toolbar-button:hover {
            opacity: 1;
            background-color: rgba(0, 0, 0, 0.04);
          }
          .dark .markdown-toolbar .toolbar-button:hover {
            background-color: rgba(255, 255, 255, 0.08);
          }
          .markdown-toolbar .toolbar-button:active {
            transform: scale(0.95);
          }
          `}
        </style>
      </div>
    )
  },
})
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-23 09:31:02Z)**_

<think><details><summary>Thought Process</summary>
**Assessing active state detection**

I'm planning to detect active styles by checking the current selection in CodeMirror and will review markdown-commands next for implementation details.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-23 09:31:03Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: 7fad88
Wall time: 0.0596 seconds
Process exited with code 0
Original token count: 1223
Output:
import type { ChangeSpec } from '@codemirror/state'
import type { EditorView } from '@codemirror/view'

function wrapSelection(
  view: EditorView,
  before: string,
  after: string = before,
  placeholder: string = '',
): boolean {
  const { state } = view
  const { from, to } = state.selection.main
  const selectedText = state.sliceDoc(from, to)

  const text = selectedText || placeholder
  const insert = `${before}${text}${after}`

  view.dispatch({
    changes: { from, to, insert },
    selection: {
      anchor: from + before.length,
      head: from + before.length + text.length,
    },
  })

  view.focus()
  return true
}

function insertAtLineStart(
  view: EditorView,
  prefix: string,
  toggle: boolean = true,
): boolean {
  const { state } = view
  const { from, to } = state.selection.main
  const firstLine = state.doc.lineAt(from)
  const lastLine = state.doc.lineAt(to)

  if (firstLine.number === lastLine.number || from === to) {
    const lineText = firstLine.text

    if (toggle && lineText.startsWith(prefix)) {
      view.dispatch({
        changes: {
          from: firstLine.from,
          to: firstLine.from + prefix.length,
          insert: '',
        },
      })
    } else {
      view.dispatch({
        changes: {
          from: firstLine.from,
          to: firstLine.from,
          insert: prefix,
        },
      })
    }
  } else {
    const indent = ' '.repeat(prefix.length)
    const changes: ChangeSpec[] = []

    for (let i = firstLine.number; i <= lastLine.number; i++) {
      const line = state.doc.line(i)
      const linePrefix = i === firstLine.number ? prefix : indent
      changes.push({
        from: line.from,
        to: line.from,
        insert: linePrefix,
      })
    }

    view.dispatch({ changes })
  }

  view.focus()
  return true
}

function insertBlock(
  view: EditorView,
  template: string,
  cursorOffset: number = 0,
): boolean {
  const { state } = view
  const { from } = state.selection.main
  const line = state.doc.lineAt(from)

  const insertPos = line.to
  const needsNewline = line.text.length > 0
  const insert = (needsNewline ? '\n' : '') + template

  view.dispatch({
    changes: { from: insertPos, to: insertPos, insert },
    selection: {
      anchor: insertPos + insert.length + cursorOffset,
    },
  })

  view.focus()
  return true
}

export const setHeadingLevel = (view: EditorView, level: number): boolean => {
  const normalizedLevel = Math.min(6, Math.max(1, level))
  const { state } = view
  const line = state.doc.lineAt(state.selection.main.from)
  const lineText = line.text
  const prefix = `${'#'.repeat(normalizedLevel)} `
  const match = lineText.match(/^(#{1,6})\s/)

  if (match) {
    view.dispatch({
      changes: {
        from: line.from,
        to: line.from + match[0].length,
        insert: prefix,
      },
    })
  } else {
    view.dispatch({
      changes: {
        from: line.from,
        to: line.from,
        insert: prefix,
      },
    })
  }

  view.focus()
  return true
}

export const commands = {
  bold: (view: EditorView) => wrapSelection(view, '**', '**', '粗体文本'),
  italic: (view: EditorView) => wrapSelection(view, '*', '*', '斜体文本'),
  strikethrough: (view: EditorView) =>
    wrapSelection(view, '~~', '~~', '删除文本'),
  inlineCode: (view: EditorView) => wrapSelection(view, '`', '`', 'code'),
  codeBlock: (view: EditorView) => {
    const { state } = view
    const { from, to } = state.selection.main
    const selectedText = state.sliceDoc(from, to)

    if (selectedText) {
      const insert = `\`\`\`\n${selectedText}\n\`\`\``

      view.dispatch({
        changes: { from, to, insert },
        selection: {
          anchor: from + 4,
          head: from + 4,
        },
      })
    } else {
      const template = `\n\`\`\`javascript\n// 代码\n\`\`\`\n`
      return insertBlock(view, template, -18)
    }

    view.focus()
    return true
  },

  link: (view: EditorView) => {
    const { state } = view
    const { from, to } = state.selection.main
    const selectedText = state.sliceDoc(from, to)

    const text = selectedText || '链接文本'
    const insert = `[${text}](https://)`

    view.dispatch({
      changes: { from, to, insert },
      selection: {
        anchor: from + insert.length - 1,
      },
    })

    view.focus()
    return true
  },

  heading: (view: EditorView) => {
    const { state } = view
    const line = state.doc.lineAt(state.selection.main.from)
    const lineText = line.text

    const match = lineText.match(/^(#{1,6})\s/)

    if (match) {
      const currentLevel = match[1].length
      const nextLevel = currentLevel >= 6 ? 1 : currentLevel + 1
      const newPrefix = `${'#'.repeat(nextLevel)} `

      view.dispatch({
        changes: {
          from: line.from,
          to: line.from + match[0].length,
          insert: newPrefix,
        },
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-23 09:31:05Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: 61731a
Wall time: 0.0509 seconds
Process exited with code 0
Original token count: 471
Output:
        },
      })
    } else {
      insertAtLineStart(view, '# ', false)
    }

    view.focus()
    return true
  },

  bulletList: (view: EditorView) => insertAtLineStart(view, '- '),
  orderedList: (view: EditorView) => {
    const { state } = view
    const line = state.doc.lineAt(state.selection.main.from)

    let prevNumber = 1
    if (line.number > 1) {
      const prevLine = state.doc.line(line.number - 1)
      const match = prevLine.text.match(/^(\d+)\.\s/)
      if (match) {
        prevNumber = parseInt(match[1]) + 1
      }
    }

    return insertAtLineStart(view, `${prevNumber}. `, false)
  },

  taskList: (view: EditorView) => insertAtLineStart(view, '- [ ] '),
  quote: (view: EditorView) => {
    const { state } = view
    const { from, to } = state.selection.main
    const firstLine = state.doc.lineAt(from)
    const lastLine = state.doc.lineAt(to)

    if (firstLine.number !== lastLine.number && from !== to) {
      const changes: ChangeSpec[] = []

      for (let i = firstLine.number; i <= lastLine.number; i++) {
        const line = state.doc.line(i)
        changes.push({
          from: line.from,
          to: line.from,
          insert: '> ',
        })
      }

      view.dispatch({ changes })
      view.focus()
      return true
    }

    return insertAtLineStart(view, '> ')
  },
  horizontalRule: (view: EditorView) => insertBlock(view, '\n---\n', 0),
  emoji: (view: EditorView, emoji: string) => {
    const { state } = view
    const { from } = state.selection.main

    view.dispatch({
      changes: { from, to: from, insert: emoji },
      selection: { anchor: from + emoji.length },
    })

    view.focus()
    return true
  },

  // managed by historyKeymap
  undo: (_view: EditorView) => {
    return true
  },
  redo: (_view: EditorView) => {
    return true
  },
}

export type CommandName = keyof typeof commands
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-23 09:31:09Z)**_

<think><details><summary>Thought Process</summary>
**Searching for editor construction and toolbar usage**
</details></think>

_**Agent (gpt-5.2-codex 2026-01-23 09:31:10Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: e73a5e
Wall time: 0.0523 seconds
Process exited with code 0
Original token count: 616
Output:
src/components/editor/slash-menu/slash-menu-items.ts:26:import { commands, setHeadingLevel } from '../toolbar/markdown-commands'
src/components/editor/toolbar/floating-toolbar.css:2:.floating-toolbar-enter-active {
src/components/editor/toolbar/floating-toolbar.css:6:.floating-toolbar-leave-active {
src/components/editor/toolbar/floating-toolbar.css:10:.floating-toolbar-enter-from,
src/components/editor/toolbar/floating-toolbar.css:11:.floating-toolbar-leave-to {
src/components/editor/toolbar/floating-toolbar.tsx:17:import './floating-toolbar.css'
src/components/editor/toolbar/floating-toolbar.tsx:124:          enterActiveClass="floating-toolbar-enter-active"
src/components/editor/toolbar/floating-toolbar.tsx:125:          leaveActiveClass="floating-toolbar-leave-active"
src/components/editor/toolbar/floating-toolbar.tsx:126:          enterFromClass="floating-toolbar-enter-from"
src/components/editor/toolbar/floating-toolbar.tsx:127:          leaveToClass="floating-toolbar-leave-to"
src/components/editor/toolbar/floating-toolbar.tsx:132:                'floating-toolbar',
src/components/editor/toolbar/toolbar.tsx:36:export const MarkdownToolbar = defineComponent({
src/components/editor/toolbar/toolbar.tsx:37:  name: 'MarkdownToolbar',
src/components/editor/toolbar/toolbar.tsx:193:                  class="toolbar-button inline-flex cursor-pointer items-center justify-center border-none bg-transparent outline-none"
src/components/editor/toolbar/toolbar.tsx:217:      <div class="markdown-toolbar flex items-center gap-2 py-2 pl-2 pr-4">
src/components/editor/toolbar/toolbar.tsx:259:          .markdown-toolbar {
src/components/editor/toolbar/toolbar.tsx:262:          .markdown-toolbar .toolbar-button {
src/components/editor/toolbar/toolbar.tsx:268:          .markdown-toolbar .toolbar-button:hover {
src/components/editor/toolbar/toolbar.tsx:272:          .dark .markdown-toolbar .toolbar-button:hover {
src/components/editor/toolbar/toolbar.tsx:275:          .markdown-toolbar .toolbar-button:active {
src/components/editor/toolbar/index.tsx:1:export { MarkdownToolbar } from './toolbar'
src/components/editor/codemirror/use-codemirror.ts:22:import { createToolbarKeymapExtension } from '../toolbar'
src/components/editor/codemirror/codemirror.tsx:8:import { FloatingToolbar } from '../toolbar/floating-toolbar'
src/components/editor/codemirror/codemirror.tsx:9:import { useSelectionPosition } from '../toolbar/use-selection-position'
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-23 09:31:13Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: f2878a
Wall time: 0.0525 seconds
Process exited with code 0
Original token count: 1416
Output:
/* eslint-disable vue/no-setup-props-destructure */
import { defineComponent, watch } from 'vue'
import type { EditorState } from '@codemirror/state'
import type { PropType } from 'vue'

import { useSaveConfirm } from '~/hooks/use-save-confirm'

import { FloatingToolbar } from '../toolbar/floating-toolbar'
import { useSelectionPosition } from '../toolbar/use-selection-position'
import styles from '../universal/editor.module.css'
import { editorBaseProps } from '../universal/props'
import { SlashMenu, slashMenuExtension } from '../slash-menu'

import 'katex/dist/katex.min.css'
import './codemirror.css'

import {
  codemirrorReconfigureExtensionMap,
  wysiwygModeExtension,
} from './extension'
import { ImageEditPopover } from './ImageEditPopover'
import { useCodeMirror } from './use-codemirror'
import { blockquoteWysiwygExtension } from './wysiwyg-blockquote'
import { codeBlockWysiwygExtension } from './wysiwyg-codeblock'
import { dividerWysiwygExtension } from './wysiwyg-divider'
import { emptyLineWysiwygExtension } from './wysiwyg-empty-line'
import { headingWysiwygExtension } from './wysiwyg-heading'
import { inlineWysiwygExtension } from './wysiwyg-inline'
import { listWysiwygExtension } from './wysiwyg-list'
import { mathWysiwygExtension } from './wysiwyg-math'
import { wysiwygMeasureExtension } from './wysiwyg-measure'

export const CodemirrorEditor = defineComponent({
  name: 'CodemirrorEditor',
  props: {
    ...editorBaseProps,
    onStateChange: {
      type: Function as PropType<(state: EditorState) => void>,
      required: false,
    },
    onArrowUpAtFirstLine: {
      type: Function as PropType<() => void>,
      required: false,
    },
    className: {
      type: String,
    },
  },
  setup(props, { expose }) {
    const [refContainer, editorView] = useCodeMirror({
      initialDoc: props.text,
      onChange: (state) => {
        props.onChange(state.doc.toString())
        props.onStateChange?.(state)
      },
      onArrowUpAtFirstLine: props.onArrowUpAtFirstLine,
    })

    watch(
      () => props.text,
      (n) => {
        const editor = editorView.value

        if (editor && n != editor.state.doc.toString()) {
          editor.dispatch({
            changes: { from: 0, to: editor.state.doc.length, insert: n },
          })
        }
      },
    )

    watch(
      () => [props.renderMode, editorView.value],
      ([renderMode]) => {
        const view = editorView.value
        if (!view) return

        const hadFocus = view.hasFocus
        const isWysiwyg = (renderMode ?? 'plain') === 'wysiwyg'
        const extensions = isWysiwyg
          ? [
              ...dividerWysiwygExtension,
              ...headingWysiwygExtension,
              ...listWysiwygExtension,
              ...blockquoteWysiwygExtension,
              ...mathWysiwygExtension,
              ...inlineWysiwygExtension,
              ...codeBlockWysiwygExtension,
              ...emptyLineWysiwygExtension,
              wysiwygMeasureExtension,
            ]
          : []

        view.dispatch({
          effects: [
            codemirrorReconfigureExtensionMap.wysiwyg.reconfigure(extensions),
            codemirrorReconfigureExtensionMap.wysiwygMode.reconfigure(
              isWysiwyg ? [wysiwygModeExtension] : [],
            ),
            codemirrorReconfigureExtensionMap.slashMenu.reconfigure(
              isWysiwyg ? slashMenuExtension : [],
            ),
          ],
        })
        view.requestMeasure()

        if (hadFocus) {
          requestAnimationFrame(() => view.focus())
        }
      },
      {
        immediate: true,
        flush: 'post',
      },
    )

    expose({
      setValue: (value: string) => {
        const editor = editorView.value
        if (editor) {
          editor.dispatch({
            changes: { from: 0, to: editor.state.doc.length, insert: value },
          })
        }
      },
      focus: () => {
        editorView.value?.focus()
      },
    })

    const memoedText = props.text

    useSaveConfirm(
      props.unSaveConfirm,
      () => memoedText === editorView.value?.state.doc.toString(),
    )

    // 浮动工具栏选区位置追踪
    const { position, hasSelection } = useSelectionPosition(editorView)

    // 点击空白区域聚焦编辑器并将光标移到对应位置 (WYSIWYG 模式)
    const handleContainerPointerDown = (e: PointerEvent) => {
      const view = editorView.value
      if (!view) return

      const isWysiwyg = (props.renderMode ?? 'plain') === 'wysiwyg'
      if (!isWysiwyg) return

      if (e.button !== 0) return

      const path = e.composedPath()
      if (path.includes(view.contentDOM)) return

      const target = e.target
      if (target instanceof Node && view.contentDOM.contains(target)) return

      const pos = view.posAtCoords({ x: e.clientX, y: e.clientY })
      if (pos == null) return

      e.preventDefau
... (truncated)
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-23 09:31:16Z)**_

<think><details><summary>Thought Process</summary>
**Confirming selection style location**

The selection style detection logic is likely within the floating toolbar component, guiding where to focus next.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-23 09:31:17Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: 063ad1
Wall time: 0.0513 seconds
Process exited with code 0
Original token count: 1764
Output:
import {
  Bold,
  Code,
  Heading1,
  Heading2,
  Heading3,
  Italic,
  Link,
  Strikethrough,
} from 'lucide-vue-next'
import { defineComponent, Teleport, Transition } from 'vue'
import type { EditorView } from '@codemirror/view'
import type { Component, PropType } from 'vue'
import type { SelectionPosition } from './use-selection-position'

import { commands, setHeadingLevel } from './markdown-commands'
import './floating-toolbar.css'

interface ToolbarButton {
  icon: Component
  title: string
  shortcut: string
  action: (view: EditorView) => void
}

interface ToolbarGroup {
  id: string
  buttons: ToolbarButton[]
}

export const FloatingToolbar = defineComponent({
  name: 'FloatingToolbar',
  props: {
    editorView: {
      type: Object as PropType<EditorView | undefined>,
      required: true,
    },
    visible: {
      type: Boolean,
      required: true,
    },
    position: {
      type: Object as PropType<SelectionPosition | null>,
      default: null,
    },
  },
  setup(props) {
    const groups: ToolbarGroup[] = [
      {
        id: 'heading',
        buttons: [
          {
            icon: Heading1,
            title: '标题 1',
            shortcut: '⌘1',
            action: (view) => setHeadingLevel(view, 1),
          },
          {
            icon: Heading2,
            title: '标题 2',
            shortcut: '⌘2',
            action: (view) => setHeadingLevel(view, 2),
          },
          {
            icon: Heading3,
            title: '标题 3',
            shortcut: '⌘3',
            action: (view) => setHeadingLevel(view, 3),
          },
        ],
      },
      {
        id: 'format',
        buttons: [
          {
            icon: Bold,
            title: '粗体',
            shortcut: '⌘B',
            action: commands.bold,
          },
          {
            icon: Italic,
            title: '斜体',
            shortcut: '⌘I',
            action: commands.italic,
          },
          {
            icon: Strikethrough,
            title: '删除线',
            shortcut: '⌘D',
            action: commands.strikethrough,
          },
        ],
      },
      {
        id: 'insert',
        buttons: [
          {
            icon: Link,
            title: '链接',
            shortcut: '⌘K',
            action: commands.link,
          },
          {
            icon: Code,
            title: '代码',
            shortcut: '⌘E',
            action: commands.inlineCode,
          },
        ],
      },
    ]

    const executeCommand = (action: (view: EditorView) => void) => {
      if (props.editorView) {
        action(props.editorView)
        props.editorView.focus()
      }
    }

    return () => (
      <Teleport to="body">
        <Transition
          enterActiveClass="floating-toolbar-enter-active"
          leaveActiveClass="floating-toolbar-leave-active"
          enterFromClass="floating-toolbar-enter-from"
          leaveToClass="floating-toolbar-leave-to"
        >
          {props.visible && props.position && (
            <div
              class={[
                'floating-toolbar',
                'fixed z-50',
                'flex items-center',
                'rounded-xl',
                'bg-white/95 dark:bg-neutral-900/95',
                'backdrop-blur-xl backdrop-saturate-150',
                'border border-neutral-200/60 dark:border-neutral-700/60',
                'shadow-xl shadow-neutral-900/10 dark:shadow-neutral-950/50',
                'p-1',
              ]}
              style={{
                left: `${props.position.x}px`,
                top: props.position.above
                  ? `${props.position.y - 52}px`
                  : `${props.position.y + 8}px`,
                transform: 'translateX(-50%)',
              }}
              onMousedown={(e) => e.preventDefault()}
            >
              {groups.map((group, groupIndex) => (
                <div key={group.id} class="flex items-center">
                  {groupIndex > 0 && (
                    <div class="mx-1 h-5 w-px bg-neutral-200 dark:bg-neutral-700" />
                  )}
                  <div class="flex items-center gap-0.5">
                    {group.buttons.map((button) => (
                      <button
                        key={button.title}
                        onClick={() => executeCommand(button.action)}
                        class={[
                          'group relative flex items-center justify-center',
                          'size-8 rounded-lg',
                          'text-neutral-500 dark:text-neutral-400',
                          'transition-all duration-150',
                          'hover:bg-neutral-100 dark:hover:bg-neutral-800',
                          'hover:text-neutral-900 dark:hover:text-neutral-100',
                          'active:scale-95',
                        ]}
       
... (truncated)
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-23 09:31:20Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: 901c9c
Wall time: 0.0519 seconds
Process exited with code 0
Original token count: 4
Output:
    )
  },
})
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-23 09:31:31Z)**_

<think><details><summary>Thought Process</summary>
**Planning toggle and active state for toolbar styles**

The toolbar lacks detection of whether the selected text already has a style, causing repeated style application; next, I'll explore toggling styles by detecting current markup on selection and adding active states for toolbar buttons, likely using CodeMirror's selection info or searching for existing selection utilities.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-23 09:31:31Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: 06d21f
Wall time: 0.0526 seconds
Process exited with code 0
Original token count: 977
Output:
import { onUnmounted, ref, watch } from 'vue'
import type { EditorView } from '@codemirror/view'
import type { Ref } from 'vue'

export interface SelectionPosition {
  x: number
  y: number
  above: boolean
}

const findScrollableParent = (el: HTMLElement | null): HTMLElement | null => {
  while (el) {
    if (el.classList.contains('n-scrollbar-container')) {
      return el
    }
    const style = getComputedStyle(el)
    const overflowY = style.overflowY
    if (
      (overflowY === 'auto' || overflowY === 'scroll') &&
      el.scrollHeight > el.clientHeight
    ) {
      return el
    }
    el = el.parentElement
  }
  return null
}

export function useSelectionPosition(editorView: Ref<EditorView | undefined>) {
  const position = ref<SelectionPosition | null>(null)
  const hasSelection = ref(false)
  const selectionText = ref('')
  const scrollerRef = ref<HTMLElement | null>(null)

  let updateTimeout: ReturnType<typeof setTimeout> | null = null

  const updatePosition = () => {
    const view = editorView.value
    if (!view) {
      hasSelection.value = false
      position.value = null
      selectionText.value = ''
      return
    }

    const { from, to } = view.state.selection.main

    if (from === to) {
      hasSelection.value = false
      position.value = null
      selectionText.value = ''
      return
    }

    selectionText.value = view.state.sliceDoc(from, to)
    hasSelection.value = true

    const fromCoords = view.coordsAtPos(from)
    const toCoords = view.coordsAtPos(to)

    if (!fromCoords || !toCoords) {
      position.value = null
      return
    }

    const scroller = scrollerRef.value
    if (scroller) {
      const scrollerRect = scroller.getBoundingClientRect()
      const selectionTop = Math.min(fromCoords.top, toCoords.top)
      const selectionBottom = Math.max(fromCoords.bottom, toCoords.bottom)

      const isOutOfView =
        selectionBottom < scrollerRect.top || selectionTop > scrollerRect.bottom

      if (isOutOfView) {
        position.value = null
        return
      }
    }

    const selectionCenterX = (fromCoords.left + toCoords.right) / 2
    const selectionTop = Math.min(fromCoords.top, toCoords.top)
    const selectionBottom = Math.max(fromCoords.bottom, toCoords.bottom)

    const viewportTop = 120
    const above = selectionTop > viewportTop

    position.value = {
      x: selectionCenterX,
      y: above ? selectionTop : selectionBottom,
      above,
    }
  }

  const debouncedUpdate = () => {
    if (updateTimeout) clearTimeout(updateTimeout)
    updateTimeout = setTimeout(updatePosition, 50)
  }

  const handleMouseUp = () => debouncedUpdate()
  const handleKeyUp = (e: KeyboardEvent) => {
    if (
      e.key === 'Shift' ||
      e.key.startsWith('Arrow') ||
      e.ctrlKey ||
      e.metaKey
    ) {
      debouncedUpdate()
    }
  }

  const handleScroll = () => {
    if (hasSelection.value) {
      updatePosition()
    }
  }

  watch(
    editorView,
    (view, _, onCleanup) => {
      if (!view) return

      const scroller = findScrollableParent(view.dom) ?? view.scrollDOM
      scrollerRef.value = scroller

      view.dom.addEventListener('mouseup', handleMouseUp)
      view.dom.addEventListener('keyup', handleKeyUp)
      scroller.addEventListener('scroll', handleScroll, { passive: true })

      updatePosition()

      onCleanup(() => {
        view.dom.removeEventListener('mouseup', handleMouseUp)
        view.dom.removeEventListener('keyup', handleKeyUp)
        scroller.removeEventListener('scroll', handleScroll)
      })
    },
    { immediate: true },
  )

  onUnmounted(() => {
    if (updateTimeout) clearTimeout(updateTimeout)
  })

  const clearSelection = () => {
    hasSelection.value = false
    position.value = null
    selectionText.value = ''
  }

  return {
    position,
    hasSelection,
    selectionText,
    clearSelection,
    updatePosition,
  }
}
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-23 09:31:50Z)**_

<think><details><summary>Thought Process</summary>
**Planning detection of inline styles in selection**

I need to detect if the current selection is wrapped with inline style markers (like bold or italic) by inspecting the document around the selection instead of relying solely on selected text. Since selection may exclude markers, this requires checking text adjacency. I'll explore adding helpers in the toolbar to set active style states and possibly enhance command logic to support toggling inline styles properly, considering both markdown and WYSIWYG modes where markers might be hidden.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-23 09:31:50Z)**_

<think><details><summary>Thought Process</summary>
**Defining toggle logic for inline styles**

I'm refining commands to toggle inline styles by detecting if the selection is already wrapped with style markers and unwrapping rather than rewrapping to prevent duplication. This involves checking document slices around the selection for multi-character markers and adjusting wrapSelection accordingly. I'll also review the inlineWysiwygExtension to understand how hidden markers affect detection and toggling.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-23 09:31:50Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: cc6b49
Wall time: 0.0520 seconds
Process exited with code 0
Original token count: 1279
Output:
import { codeToHtml } from 'shiki'
import type { EditorState, Range } from '@codemirror/state'
import type { DecorationSet } from '@codemirror/view'

import { StateField } from '@codemirror/state'
import { Decoration, EditorView, WidgetType } from '@codemirror/view'

import { imageHeightChangedEffect, ImageWidget } from './wysiwyg-image'

// Hidden marker widget - displays nothing
class HiddenMarkerWidget extends WidgetType {
  constructor(readonly marker: string) {
    super()
  }

  toDOM(): HTMLElement {
    const span = document.createElement('span')
    span.className = 'cm-wysiwyg-hidden-marker'
    span.textContent = this.marker
    return span
  }

  eq(other: HiddenMarkerWidget): boolean {
    return this.marker === other.marker
  }

  ignoreEvent(): boolean {
    return false
  }
}

// Link URL widget - shows a small link indicator
class LinkUrlWidget extends WidgetType {
  constructor(readonly url: string) {
    super()
  }

  toDOM(): HTMLElement {
    const span = document.createElement('span')
    span.className = 'cm-wysiwyg-link-url'
    span.textContent = `](${this.url})`
    span.title = this.url
    return span
  }

  eq(other: LinkUrlWidget): boolean {
    return this.url === other.url
  }

  ignoreEvent(): boolean {
    return false
  }
}

// Inline code widget with shiki highlighting
class InlineCodeWidget extends WidgetType {
  private static highlightCache = new Map<string, string>()
  private static pendingHighlights = new Map<string, Promise<string>>()

  constructor(
    readonly code: string,
    readonly isDark: boolean,
  ) {
    super()
  }

  toDOM(view: EditorView): HTMLElement {
    const span = document.createElement('span')
    span.className = 'cm-wysiwyg-inline-code'
    span.textContent = this.code

    // Try to get cached highlight
    const cacheKey = `${this.code}:${this.isDark}`
    const cached = InlineCodeWidget.highlightCache.get(cacheKey)
    if (cached) {
      span.innerHTML = cached
      view.requestMeasure()
      return span
    }

    // Check if highlight is already pending
    const pending = InlineCodeWidget.pendingHighlights.get(cacheKey)
    if (pending) {
      pending.then((html) => {
        if (span.isConnected) {
          span.innerHTML = html
          view.requestMeasure()
        }
      })
      return span
    }

    // Start async highlight
    const highlightPromise = this.highlight()
    InlineCodeWidget.pendingHighlights.set(cacheKey, highlightPromise)

    highlightPromise.then((html) => {
      InlineCodeWidget.highlightCache.set(cacheKey, html)
      InlineCodeWidget.pendingHighlights.delete(cacheKey)
      if (span.isConnected) {
        span.innerHTML = html
        view.requestMeasure()
      }
    })

    return span
  }

  private async highlight(): Promise<string> {
    try {
      const html = await codeToHtml(this.code, {
        lang: 'text',
        theme: this.isDark ? 'github-dark' : 'github-light',
      })
      // Extract just the code content, remove pre/code wrappers
      const match = html.match(/<code[^>]*>([\s\S]*?)<\/code>/)
      return match ? match[1] : this.code
    } catch {
      return this.code
    }
  }

  eq(other: InlineCodeWidget): boolean {
    return this.code === other.code && this.isDark === other.isDark
  }

  ignoreEvent(): boolean {
    return false
  }
}

interface InlineMatch {
  start: number
  end: number
  markerStart: string
  markerEnd: string
  contentStart: number
  contentEnd: number
  className: string
  // For links
  linkUrl?: string
  linkUrlStart?: number
  linkUrlEnd?: number
  // For images
  isImage?: boolean
  imageAlt?: string
  imageUrl?: string
  // For inline code
  isInlineCode?: boolean
  codeContent?: string
}

// Find all inline patterns in a line
const findInlinePatterns = (
  lineText: string,
  lineFrom: number,
  _lineTo: number,
): InlineMatch[] => {
  const matches: InlineMatch[] = []
  let match: RegExpExecArray | null

  // Inline code: `code` (must be before other patterns to avoid conflicts)
  const inlineCodeRegex = /`([^`]+)`/g
  while ((match = inlineCodeRegex.exec(lineText)) !== null) {
    matches.push({
      start: lineFrom + match.index,
      end: lineFrom + match.index + match[0].length,
      markerStart: '`',
      markerEnd: '`',
      contentStart: lineFrom + match.index + 1,
      contentEnd: lineFrom + match.index + match[0].length - 1,
      className: 'cm-wysiwyg-inline-code',
      isInlineCode: true,
      codeContent: match[1],
    })
  }

  // Image: ![alt](url)
  const imageRegex = /!\[([^\]]*)\]\(([^)]+)\)/g
  while ((match = imageRegex.exec(lineText)) !== null) {
    const fullMatch = match[0]
    const alt = match[1]
    const url = match[2]
    const matchStart = lineFrom + match.index

    matches.push({
      start: matchStart,
      end: matchStart + fullMatch.length,
      markerStart: '![',
      markerEnd: ']',
      c
... (truncated)
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-23 09:31:53Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: 478d0a
Wall time: 0.0507 seconds
Process exited with code 0
Original token count: 1509
Output:
  // Bold: **text** or __text__
  const boldRegex = /(\*\*|__)(?!\s)(.+?)(?<!\s)\1/g
  while ((match = boldRegex.exec(lineText)) !== null) {
    const matchStart = lineFrom + match.index
    const matchEnd = matchStart + match[0].length

    if (isOverlapping(matches, matchStart, matchEnd)) continue

    matches.push({
      start: matchStart,
      end: matchEnd,
      markerStart: match[1],
      markerEnd: match[1],
      contentStart: matchStart + match[1].length,
      contentEnd: matchEnd - match[1].length,
      className: 'cm-wysiwyg-bold',
    })
  }

  // Strikethrough: ~~text~~
  const strikeRegex = /~~(?!\s)(.+?)(?<!\s)~~/g
  while ((match = strikeRegex.exec(lineText)) !== null) {
    const matchStart = lineFrom + match.index
    const matchEnd = matchStart + match[0].length

    if (isOverlapping(matches, matchStart, matchEnd)) continue

    matches.push({
      start: matchStart,
      end: matchEnd,
      markerStart: '~~',
      markerEnd: '~~',
      contentStart: matchStart + 2,
      contentEnd: matchEnd - 2,
      className: 'cm-wysiwyg-strikethrough',
    })
  }

  // Highlight: ==text==
  const highlightRegex = /==(?!\s)(.+?)(?<!\s)==/g
  while ((match = highlightRegex.exec(lineText)) !== null) {
    const matchStart = lineFrom + match.index
    const matchEnd = matchStart + match[0].length

    if (isOverlapping(matches, matchStart, matchEnd)) continue

    matches.push({
      start: matchStart,
      end: matchEnd,
      markerStart: '==',
      markerEnd: '==',
      contentStart: matchStart + 2,
      contentEnd: matchEnd - 2,
      className: 'cm-wysiwyg-highlight',
    })
  }

  // Link: [text](url) - but not images
  const linkRegex = /(?<!!)\[([^\]]+)\]\(([^)]+)\)/g
  while ((match = linkRegex.exec(lineText)) !== null) {
    const fullMatch = match[0]
    const text = match[1]
    const url = match[2]
    const matchStart = lineFrom + match.index

    if (isOverlapping(matches, matchStart, matchStart + fullMatch.length))
      continue

    matches.push({
      start: matchStart,
      end: matchStart + fullMatch.length,
      markerStart: '[',
      markerEnd: ']',
      contentStart: matchStart + 1,
      contentEnd: matchStart + 1 + text.length,
      className: 'cm-wysiwyg-link',
      linkUrl: url,
      linkUrlStart: matchStart + 1 + text.length,
      linkUrlEnd: matchStart + fullMatch.length,
    })
  }

  // Italic: *text* or _text_ (but not ** or __)
  const italicRegex =
    /(?<!\*)\*(?!\*)(?!\s)([^*]+?)(?<!\s)\*(?!\*)|(?<!_)_(?!_)(?!\s)([^_]+?)(?<!\s)_(?!_)/g
  while ((match = italicRegex.exec(lineText)) !== null) {
    const marker = match[0].startsWith('*') ? '*' : '_'
    const content = match[1] || match[2]
    const matchStart = lineFrom + match.index
    const matchEnd = matchStart + match[0].length

    if (isOverlapping(matches, matchStart, matchEnd)) continue

    if (content) {
      matches.push({
        start: matchStart,
        end: matchEnd,
        markerStart: marker,
        markerEnd: marker,
        contentStart: matchStart + 1,
        contentEnd: matchEnd - 1,
        className: 'cm-wysiwyg-italic',
      })
    }
  }

  return matches.sort((a, b) => a.start - b.start)
}

// Check if a range overlaps with existing matches
const isOverlapping = (
  matches: InlineMatch[],
  start: number,
  end: number,
): boolean => {
  return matches.some(
    (m) =>
      (start >= m.start && start < m.end) || (end > m.start && end <= m.end),
  )
}

// Cache for hidden marker widgets
const hiddenMarkerCache = new Map<string, HiddenMarkerWidget>()
const getHiddenMarker = (marker: string): HiddenMarkerWidget => {
  let widget = hiddenMarkerCache.get(marker)
  if (!widget) {
    widget = new HiddenMarkerWidget(marker)
    hiddenMarkerCache.set(marker, widget)
  }
  return widget
}

// Check if cursor is within a range
const isCursorInRange = (
  state: EditorState,
  start: number,
  end: number,
): boolean => {
  const { from, to } = state.selection.main
  return from < end && to > start
}

// Detect dark mode
const isDarkMode = (): boolean => {
  return document.documentElement.classList.contains('dark')
}

const buildInlineDecorations = (state: EditorState): DecorationSet => {
  const decorations: Range<Decoration>[] = []
  const dark = isDarkMode()

  for (let lineNumber = 1; lineNumber <= state.doc.lines; lineNumber++) {
    const line = state.doc.line(lineNumber)
    const matches = findInlinePatterns(line.text, line.from, line.to)

    for (const match of matches) {
      // For images, always show the widget (no cursor detection)
      // Other inline elements still use cursor detection
      if (match.isImage && match.imageUrl) {
        const matchText = line.text.slice(
          match.start - line.from,
          match.end - line.from,
        )
        const isBlockImage = line.text.trim() === matchText
        const imageFrom = isBlockImage ?
... (truncated)
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-23 09:31:56Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: b7f3d6
Wall time: 0.0515 seconds
Process exited with code 0
Original token count: 406
Output:
      } else {
        // Hide start marker
        decorations.push(
          Decoration.replace({
            widget: getHiddenMarker(match.markerStart),
          }).range(match.start, match.contentStart),
        )

        // Style the content
        decorations.push(
          Decoration.mark({ class: match.className }).range(
            match.contentStart,
            match.contentEnd,
          ),
        )

        // For links, handle the URL part specially
        if (match.linkUrl && match.linkUrlStart !== undefined) {
          decorations.push(
            Decoration.replace({
              widget: new LinkUrlWidget(match.linkUrl),
            }).range(match.contentEnd, match.end),
          )
        } else {
          // Hide end marker
          decorations.push(
            Decoration.replace({
              widget: getHiddenMarker(match.markerEnd),
            }).range(match.contentEnd, match.end),
          )
        }
      }
    }
  }

  return Decoration.set(decorations, true)
}

const inlineWysiwygField = StateField.define<DecorationSet>({
  create(state) {
    return buildInlineDecorations(state)
  },
  update(value, tr) {
    const selectionChanged = !tr.startState.selection.eq(tr.state.selection)
    const hasImageHeightChange = tr.effects.some((effect) =>
      effect.is(imageHeightChangedEffect),
    )

    if (tr.docChanged || selectionChanged || hasImageHeightChange) {
      return buildInlineDecorations(tr.state)
    }

    return value
  },
  provide: (field) => EditorView.decorations.from(field),
})

export const inlineWysiwygExtension = [inlineWysiwygField]
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-23 09:34:23Z)**_

<think><details><summary>Thought Process</summary>
**Planning inline style detection**

I'm outlining detection of inline styles by checking if the selection is inside or fully within markdown markers using range checks and surrounding text scans, aiming to centralize this logic for toolbar and slash menu with performant, simplified regex and marker matching.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-23 09:34:23Z)**_

<think><details><summary>Thought Process</summary>
**Designing precise inline style detection and toggling**

I'm defining a detailed approach to detect inline markdown styles per selection line using regex matches for bold, italic, strikethrough, and inline code, then toggling by unwrapping markers if selection is within such a match; this includes exporting shared helpers for toolbar active state and carefully adjusting selection after marker removal.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-23 09:34:23Z)**_

<think><details><summary>Thought Process</summary>
**Extending toolbar with reactive inline style active states**

I'm planning a reactive toolbar update that tracks editor selection changes via listeners to recompute and show active inline styles (bold, italic, strike, code) on buttons using exported format detection helpers, and modifying toggle commands to unwrap styles safely while adjusting selection consistently.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-23 09:34:37Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>

**Input:**

- cmd: `apply_patch <<'PATCH'
*** Begin Patch
*** Update File: src/components/editor/toolbar/markdown-commands.ts
@@
-function wrapSelection(
-  view: EditorView,
-  before: string,
-  after: string = before,
-  placeholder: string = '',
-): boolean {
+export type InlineFormat =
+  | 'bold'
+  | 'italic'
+  | 'strikethrough'
+  | 'inlineCode'
+
+interface InlineMatch {
+  start: number
+  end: number
+  contentStart: number
+  contentEnd: number
+  markerStart: string
+  markerEnd: string
+}
+
+const findInlineMatches = (
+  lineText: string,
+  lineFrom: number,
+  format: InlineFormat,
+): InlineMatch[] => {
+  const matches: InlineMatch[] = []
+  let match: RegExpExecArray | null
+
+  if (format === 'inlineCode') {
+    const regex = /`([^`]+)`/g
+    while ((match = regex.exec(lineText)) !== null) {
+      const start = lineFrom + match.index
+      const end = start + match[0].length
+      matches.push({
+        start,
+        end,
+        contentStart: start + 1,
+        contentEnd: end - 1,
+        markerStart: '`',
+        markerEnd: '`',
+      })
+    }
+    return matches
+  }
+
+  if (format === 'bold') {
+    const regex = /(\*\*|__)(?!\s)(.+?)(?<!\s)\1/g
+    while ((match = regex.exec(lineText)) !== null) {
+      const marker = match[1]
+      const start = lineFrom + match.index
+      const end = start + match[0].length
+      matches.push({
+        start,
+        end,
+        contentStart: start + marker.length,
+        contentEnd: end - marker.length,
+        markerStart: marker,
+        markerEnd: marker,
+      })
+    }
+    return matches
+  }
+
+  if (format === 'strikethrough') {
+    const regex = /~~(?!\s)(.+?)(?<!\s)~~/g
+    while ((match = regex.exec(lineText)) !== null) {
+      const start = lineFrom + match.index
+      const end = start + match[0].length
+      matches.push({
+        start,
+        end,
+        contentStart: start + 2,
+        contentEnd: end - 2,
+        markerStart: '~~',
+        markerEnd: '~~',
+      })
+    }
+    return matches
+  }
+
+  if (format === 'italic') {
+    const regex =
+      /(?<!\*)\*(?!\*)(?!\s)([^*]+?)(?<!\s)\*(?!\*)|(?<!_)_(?!_)(?!\s)([^_]+?)(?<!\s)_(?!_)/g
+    while ((match = regex.exec(lineText)) !== null) {
+      const marker = match[0].startsWith('*') ? '*' : '_'
+      const start = lineFrom + match.index
+      const end = start + match[0].length
+      matches.push({
+        start,
+        end,
+        contentStart: start + 1,
+        contentEnd: end - 1,
+        markerStart: marker,
+        markerEnd: marker,
+      })
+    }
+  }
+
+  return matches
+}
+
+const getInlineMatchForSelection = (
+  view: EditorView,
+  format: InlineFormat,
+): InlineMatch | null => {
+  const { state } = view
+  const { from, to } = state.selection.main
+  const startLine = state.doc.lineAt(from)
+  const endLine = state.doc.lineAt(to)
+
+  if (startLine.number !== endLine.number) return null
+
+  const matches = findInlineMatches(startLine.text, startLine.from, format)
+  return (
+    matches.find((matchItem) => from >= matchItem.start && to <= matchItem.end) ??
+    null
+  )
+}
+
+export const isInlineFormatActive = (
+  view: EditorView,
+  format: InlineFormat,
+): boolean => {
+  return Boolean(getInlineMatchForSelection(view, format))
+}
+
+function wrapSelection(
+  view: EditorView,
+  before: string,
+  after: string = before,
+  placeholder: string = '',
+  format?: InlineFormat,
+): boolean {
   const { state } = view
   const { from, to } = state.selection.main
   const selectedText = state.sliceDoc(from, to)
+
+  if (format) {
+    const match = getInlineMatchForSelection(view, format)
+    if (match) {
+      const contentLength = match.contentEnd - match.contentStart
+
+      view.dispatch({
+        changes: [
+          { from: match.start, to: match.contentStart, insert: '' },
+          { from: match.contentEnd, to: match.end, insert: '' },
+        ],
+        selection: {
+          anchor: match.start,
+          head: match.start + contentLength,
+        },
+      })
+
+      view.focus()
+      return true
+    }
+  }
@@
-  bold: (view: EditorView) => wrapSelection(view, '**', '**', '粗体文本'),
-  italic: (view: EditorView) => wrapSelection(view, '*', '*', '斜体文本'),
-  strikethrough: (view: EditorView) =>
-    wrapSelection(view, '~~', '~~', '删除文本'),
-  inlineCode: (view: EditorView) => wrapSelection(view, '`', '`', 'code'),
+  bold: (view: EditorView) =>
+    wrapSelection(view, '**', '**', '粗体文本', 'bold'),
+  italic: (view: EditorView) =>
+    wrapSelection(view, '*', '*', '斜体文本', 'italic'),
+  strikethrough: (view: EditorView) =>
+    wrapSelection(view, '~~', '~~', '删除文本', 'strikethrough'),
+  inlineCode: (view: EditorView) =>
+    wrapSelection(view, '`', '`', 'code', 'inlineCode'),
*** End Patch
PATCH`

**Result:**

</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-23 09:34:40Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: 17d1ca
Wall time: 0.0505 seconds
Process exited with code 0
Original token count: 11
Output:
118:export const isInlineFormatActive = (
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-23 09:34:42Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: 1d19da
Wall time: 0.0523 seconds
Process exited with code 0
Original token count: 1208
Output:
import type { ChangeSpec } from '@codemirror/state'
import type { EditorView } from '@codemirror/view'

export type InlineFormat =
  | 'bold'
  | 'italic'
  | 'strikethrough'
  | 'inlineCode'

interface InlineMatch {
  start: number
  end: number
  contentStart: number
  contentEnd: number
  markerStart: string
  markerEnd: string
}

const findInlineMatches = (
  lineText: string,
  lineFrom: number,
  format: InlineFormat,
): InlineMatch[] => {
  const matches: InlineMatch[] = []
  let match: RegExpExecArray | null

  if (format === 'inlineCode') {
    const regex = /`([^`]+)`/g
    while ((match = regex.exec(lineText)) !== null) {
      const start = lineFrom + match.index
      const end = start + match[0].length
      matches.push({
        start,
        end,
        contentStart: start + 1,
        contentEnd: end - 1,
        markerStart: '`',
        markerEnd: '`',
      })
    }
    return matches
  }

  if (format === 'bold') {
    const regex = /(\*\*|__)(?!\s)(.+?)(?<!\s)\1/g
    while ((match = regex.exec(lineText)) !== null) {
      const marker = match[1]
      const start = lineFrom + match.index
      const end = start + match[0].length
      matches.push({
        start,
        end,
        contentStart: start + marker.length,
        contentEnd: end - marker.length,
        markerStart: marker,
        markerEnd: marker,
      })
    }
    return matches
  }

  if (format === 'strikethrough') {
    const regex = /~~(?!\s)(.+?)(?<!\s)~~/g
    while ((match = regex.exec(lineText)) !== null) {
      const start = lineFrom + match.index
      const end = start + match[0].length
      matches.push({
        start,
        end,
        contentStart: start + 2,
        contentEnd: end - 2,
        markerStart: '~~',
        markerEnd: '~~',
      })
    }
    return matches
  }

  if (format === 'italic') {
    const regex =
      /(?<!\*)\*(?!\*)(?!\s)([^*]+?)(?<!\s)\*(?!\*)|(?<!_)_(?!_)(?!\s)([^_]+?)(?<!\s)_(?!_)/g
    while ((match = regex.exec(lineText)) !== null) {
      const marker = match[0].startsWith('*') ? '*' : '_'
      const start = lineFrom + match.index
      const end = start + match[0].length
      matches.push({
        start,
        end,
        contentStart: start + 1,
        contentEnd: end - 1,
        markerStart: marker,
        markerEnd: marker,
      })
    }
  }

  return matches
}

const getInlineMatchForSelection = (
  view: EditorView,
  format: InlineFormat,
): InlineMatch | null => {
  const { state } = view
  const { from, to } = state.selection.main
  const startLine = state.doc.lineAt(from)
  const endLine = state.doc.lineAt(to)

  if (startLine.number !== endLine.number) return null

  const matches = findInlineMatches(startLine.text, startLine.from, format)
  return (
    matches.find((matchItem) => from >= matchItem.start && to <= matchItem.end) ??
    null
  )
}

export const isInlineFormatActive = (
  view: EditorView,
  format: InlineFormat,
): boolean => {
  return Boolean(getInlineMatchForSelection(view, format))
}

function wrapSelection(
  view: EditorView,
  before: string,
  after: string = before,
  placeholder: string = '',
  format?: InlineFormat,
): boolean {
  const { state } = view
  const { from, to } = state.selection.main
  const selectedText = state.sliceDoc(from, to)

  if (format) {
    const match = getInlineMatchForSelection(view, format)
    if (match) {
      const contentLength = match.contentEnd - match.contentStart

      view.dispatch({
        changes: [
          { from: match.start, to: match.contentStart, insert: '' },
          { from: match.contentEnd, to: match.end, insert: '' },
        ],
        selection: {
          anchor: match.start,
          head: match.start + contentLength,
        },
      })

      view.focus()
      return true
    }
  }

  const text = selectedText || placeholder
  const insert = `${before}${text}${after}`

  view.dispatch({
    changes: { from, to, insert },
    selection: {
      anchor: from + before.length,
      head: from + before.length + text.length,
    },
  })

  view.focus()
  return true
}

function insertAtLineStart(
  view: EditorView,
  prefix: string,
  toggle: boolean = true,
): boolean {
  const { state } = view
  const { from, to } = state.selection.main
  const firstLine = state.doc.lineAt(from)
  const lastLine = state.doc.lineAt(to)

  if (firstLine.number === lastLine.number || from === to) {
    const lineText = firstLine.text

    if (toggle && lineText.startsWith(prefix)) {
      view.dispatch({
        changes: {
          from: firstLine.from,
          to: firstLine.from + prefix.length,
          insert: '',
        },
      })
    } else {
      view.dispatch({
        changes: {
          from: firstLine.from,
          to: firstLine.from,
          insert: prefix,
        },
      })
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-23 09:35:01Z)**_

<think><details><summary>Thought Process</summary>
**Planning active style detection**

I'm preparing to add active state styling for toolbar buttons by leveraging the existing inline format detection function, focusing on bold, italic, strikethrough, and inlineCode. This will update the top toolbar UI to reflect currently applied styles and reduce confusion from repeated toggling.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-23 09:35:01Z)**_

<think><details><summary>Thought Process</summary>
**Planning toolbar active state updates**

I'm deciding to add an optional active state check to toolbar buttons for inline styles, using editor view selection to compute isActive on each render. To reflect selection changes, I'll implement a reactive update triggered by editor view update listeners since the top toolbar currently lacks reactive binding to selection changes.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-23 09:35:01Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: 8b08d3
Wall time: 0.0515 seconds
Process exited with code 0
Original token count: 118
Output:
src/components/editor/codemirror/wysiwyg-measure.ts:3:export const wysiwygMeasureExtension = EditorView.updateListener.of(
src/components/editor/codemirror/use-codemirror.ts:181:        EditorView.updateListener.of((update) => {
src/components/editor/codemirror/wysiwyg-codeblock.ts:523:        EditorView.updateListener.of((update) => {
src/components/editor/codemirror/wysiwyg-codeblock.ts:1483:const autoCloseCodeBlockFocus = EditorView.updateListener.of((update) => {
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-23 09:35:04Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: d63c27
Wall time: 0.0524 seconds
Process exited with code 0
Original token count: 513
Output:
                }
              }
              return false // Use default ArrowUp behavior
            },
          },
        ]),
        createToolbarKeymapExtension(),
        keymap.of([
          ...defaultKeymap,
          ...historyKeymap,
          ...markdownKeymap,
          ...searchKeymap,
          indentWithTab,
        ]),

        lineNumbers(),
        highlightActiveLineGutter(),
        history(),
        indentOnInput(),
        bracketMatching(),
        highlightActiveLine(),
        EditorState.tabSize.of(2),
        search({
          top: true,
        }),

        syntaxTheme,

        ...codemirrorReconfigureExtension,

        EditorView.lineWrapping,
        EditorView.updateListener.of((update) => {
          if (update.changes) {
            onChange && onChange(update.state)
          }
        }),
      ],
    })

    const view = new EditorView({
      state: startState,
      parent: refContainer.value,
    })

    editorView.value = view

    const shouldDebugWysiwyg = () => {
      if (general.setting.renderMode !== 'wysiwyg') return false
      if (typeof window === 'undefined') return false
      const enabled =
        (window as unknown as { __CM_WYSIWYG_DEBUG__?: boolean })
          .__CM_WYSIWYG_DEBUG__ === true
      return enabled || window.localStorage?.getItem('cm-wysiwyg-debug') === '1'
    }

    const shorten = (text: string, max = 120) =>
      text.length > max ? `${text.slice(0, max - 1)}…` : text

    const describeNode = (node: EventTarget | null): string => {
      if (!node) return 'null'
      if (node === window) return 'window'
      if (node === document) return 'document'
      if (node instanceof Text) {
        return `#text("${shorten(node.data)}")`
      }
      if (node instanceof HTMLElement) {
        const classes = typeof node.className === 'string' ? node.className : ''
        const classHint = classes
          ? `.${classes.split(/\s+/).filter(Boolean).slice(0, 4).join('.')}`
          : ''
        const dataHint = node.dataset?.enterPos
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-23 09:35:24Z)**_

<think><details><summary>Thought Process</summary>
**Clarifying toolbar toggle behavior**

The active toolbar state will rely on toggling commands rather than tracking selection changes since selection-based events aren't available in the top toolbar. The fix ensures toggling removes repeated style applications, handling cursor inside styled text to remove formatting correctly without causing regressions.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-23 09:35:24Z)**_

<think><details><summary>Thought Process</summary>
**Confirming toggle fix suffices**

The toolbar button active state highlighting isn't strictly needed to fix repeated style application, so I'll focus on ensuring the toggle commands consistently add/remove styles across toolbars without complex selection tracking. Next, I'll suggest thorough testing given the patched behavior changes.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-23 09:35:28Z)**_

已把内联样式改成“可判断已应用并反向取消”的逻辑，避免重复包裹同一段文本。现在在选区（或光标）已处于 **粗体/斜体/删除线/行内代码** 范围内点击按钮，会移除对应标记而不是继续叠加。

改动位置：
- `src/components/editor/toolbar/markdown-commands.ts`：新增内联样式匹配与 active 判断，`wrapSelection` 里先检测并移除现有标记。

如果你还想在 UI 上高亮当前已应用的样式按钮，我可以继续加“选中态样式”并监听 selection 更新。  
建议下一步：
1) 手动在编辑器里选中已加粗的文字，再点“粗体”确认会取消样式  
2) 如需按钮高亮状态，告诉我要覆盖的按钮范围（仅内联样式 or 含标题/列表）

---

_**User (2026-01-23 09:35:52Z)**_

在UI中需要有一个选中状态的渲染

---

_**Agent (gpt-5.2-codex 2026-01-23 09:36:16Z)**_

<think><details><summary>Thought Process</summary>
**Adding active state to toolbar buttons**

Planning to implement an active class on toolbar and floating toolbar buttons using `isInlineFormatActive` based on selection; this involves setting up a reactive selectionVersion ref updated via EditorView updateListener and extending button configs with optional isActive functions for inline formats like bold, italic, strikethrough, and inlineCode.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-23 09:36:16Z)**_

<think><details><summary>Thought Process</summary>
**Implementing selection change detection with event listeners**

Decided to track selection changes by adding mouseup, keyup, and focus event listeners on editorView.dom to update a reactive ref triggering toolbar button active state updates, since adding CodeMirror updateListener extensions dynamically is complex. Next, I'll tie these listeners to editorView changes and clean up with onUnmounted.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-23 09:36:30Z)**_

<tool-use data-tool-type="write" data-tool-name="apply_patch"><details>
<summary>Tool use: **apply_patch**</summary>
**Update: `src/components/editor/toolbar/toolbar.tsx`**

```diff
@@
-import { defineComponent, ref } from 'vue'
+import { defineComponent, onUnmounted, ref, watch } from 'vue'
 import type { EditorView } from '@codemirror/view'
 import type { Component, PropType } from 'vue'
 
 import { redo, undo } from '@codemirror/commands'
 
 import { EmojiPicker } from './emoji-picker'
-import { commands } from './markdown-commands'
+import { commands, isInlineFormatActive } from './markdown-commands'
@@
 interface ToolbarButton {
   icon: Component
   title: string
   shortcut: string
   action: () => void
   divider?: boolean
+  isActive?: (view: EditorView) => boolean
 }
@@
   setup(props) {
     const emojiPickerVisible = ref(false)
     const emojiButtonRef = ref<HTMLElement>()
+    const selectionVersion = ref(0)
+    let detachSelectionListeners: (() => void) | null = null
 
     const executeCommand = (commandFn: (view: EditorView) => boolean) => {
       if (props.editorView) {
         commandFn(props.editorView)
+        selectionVersion.value += 1
       }
     }
@@
     const buttons: ToolbarButton[] = [
@@
       {
         icon: Bold,
         title: '粗体',
         shortcut: 'Ctrl+B',
         action: () => executeCommand(commands.bold),
+        isActive: (view) => isInlineFormatActive(view, 'bold'),
       },
       {
         icon: Italic,
         title: '斜体',
         shortcut: 'Ctrl+I',
         action: () => executeCommand(commands.italic),
+        isActive: (view) => isInlineFormatActive(view, 'italic'),
       },
       {
         icon: Strikethrough,
         title: '删除线',
         shortcut: 'Ctrl+D',
         action: () => executeCommand(commands.strikethrough),
+        isActive: (view) => isInlineFormatActive(view, 'strikethrough'),
       },
@@
       {
         icon: Code,
         title: '行内代码',
         shortcut: 'Ctrl+G',
         action: () => executeCommand(commands.inlineCode),
         divider: true,
+        isActive: (view) => isInlineFormatActive(view, 'inlineCode'),
       },
@@
       {
         icon: Undo2,
         title: '撤销',
         shortcut: 'Ctrl+Z',
         action: () => {
           if (props.editorView) {
             props.editorView.focus()
             undo(props.editorView)
+            selectionVersion.value += 1
           }
         },
       },
@@
       {
         icon: Redo2,
         title: '重做',
         shortcut: 'Ctrl+Y',
         action: () => {
           if (props.editorView) {
             props.editorView.focus()
             redo(props.editorView)
+            selectionVersion.value += 1
           }
         },
       },
     ]
 
+    const updateSelectionState = () => {
+      selectionVersion.value += 1
+    }
+
+    const setupSelectionListeners = (view: EditorView | undefined) => {
+      if (!view) return
+
+      const handleMouseUp = () => updateSelectionState()
+      const handleKeyUp = (e: KeyboardEvent) => {
+        if (
+          e.key === 'Shift' ||
+          e.key.startsWith('Arrow') ||
+          e.ctrlKey ||
+          e.metaKey
+        ) {
+          updateSelectionState()
+        }
+      }
+      const handleMouseDown = () => updateSelectionState()
+
+      view.dom.addEventListener('mouseup', handleMouseUp)
+      view.dom.addEventListener('keyup', handleKeyUp)
+      view.dom.addEventListener('mousedown', handleMouseDown)
+
+      detachSelectionListeners = () => {
+        view.dom.removeEventListener('mouseup', handleMouseUp)
+        view.dom.removeEventListener('keyup', handleKeyUp)
+        view.dom.removeEventListener('mousedown', handleMouseDown)
+      }
+    }
+
+    watch(
+      () => props.editorView,
+      (view) => {
+        if (detachSelectionListeners) {
+          detachSelectionListeners()
+          detachSelectionListeners = null
+        }
+        setupSelectionListeners(view)
+        updateSelectionState()
+      },
+      { immediate: true },
+    )
+
+    onUnmounted(() => {
+      if (detachSelectionListeners) {
+        detachSelectionListeners()
+      }
+    })
+
     const ToolbarButtonComponent = defineComponent({
       props: {
         button: {
@@
       setup(buttonProps) {
         return () => (
           <NPopover
@@
             {{
               trigger: () => (
                 <button
                   ref={buttonProps.isEmojiButton ? emojiButtonRef : undefined}
                   onClick={buttonProps.button.action}
-                  class="toolbar-button inline-flex cursor-pointer items-center justify-center border-none bg-transparent outline-none"
+                  class={[
+                    'toolbar-button inline-flex cursor-pointer items-center justify-center border-none bg-transparent outline-none',
+                    selectionVersion.value && props.editorView
+                      ? buttonProps.button.isActive?.(props.editorView)
+                        ? 'is-active'
+                        : ''
+                      : '',
+                  ]}
                   aria-label={buttonProps.button.title}
                 >
                   {/* @ts-ignore */}
                   <buttonProps.button.icon size={15} />
                 </button>
@@
           .markdown-toolbar .toolbar-button:hover {
             opacity: 1;
             background-color: rgba(0, 0, 0, 0.04);
           }
+          .markdown-toolbar .toolbar-button.is-active {
+            opacity: 1;
+            background-color: rgba(59, 130, 246, 0.18);
+          }
           .dark .markdown-toolbar .toolbar-button:hover {
             background-color: rgba(255, 255, 255, 0.08);
           }
+          .dark .markdown-toolbar .toolbar-button.is-active {
+            background-color: rgba(96, 165, 250, 0.25);
+          }
           .markdown-toolbar .toolbar-button:active {
             transform: scale(0.95);
           }
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-23 09:36:38Z)**_

<think><details><summary>Thought Process</summary>
**Planning active state in floating toolbar**

The floating toolbar needs an active state that updates on selection style changes, which requires adding local selectionVersion and update listeners similar to the main toolbar. I'll patch floating-toolbar.tsx to add these listeners and use isInlineFormatActive for button states, skipping heading buttons.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-23 09:36:52Z)**_

<tool-use data-tool-type="write" data-tool-name="apply_patch"><details>
<summary>Tool use: **apply_patch**</summary>
**Update: `src/components/editor/toolbar/floating-toolbar.tsx`**

```diff
@@
-import { defineComponent, Teleport, Transition } from 'vue'
+import { defineComponent, onUnmounted, ref, Teleport, Transition, watch } from 'vue'
 import type { EditorView } from '@codemirror/view'
 import type { Component, PropType } from 'vue'
 import type { SelectionPosition } from './use-selection-position'
 
-import { commands, setHeadingLevel } from './markdown-commands'
+import { commands, isInlineFormatActive, setHeadingLevel } from './markdown-commands'
@@
 interface ToolbarButton {
   icon: Component
   title: string
   shortcut: string
   action: (view: EditorView) => void
+  isActive?: (view: EditorView) => boolean
 }
@@
   setup(props) {
+    const selectionVersion = ref(0)
+    let detachSelectionListeners: (() => void) | null = null
+
     const groups: ToolbarGroup[] = [
       {
         id: 'heading',
@@
           {
             icon: Bold,
             title: '粗体',
             shortcut: '⌘B',
             action: commands.bold,
+            isActive: (view) => isInlineFormatActive(view, 'bold'),
           },
           {
             icon: Italic,
             title: '斜体',
             shortcut: '⌘I',
             action: commands.italic,
+            isActive: (view) => isInlineFormatActive(view, 'italic'),
           },
           {
             icon: Strikethrough,
             title: '删除线',
             shortcut: '⌘D',
             action: commands.strikethrough,
+            isActive: (view) => isInlineFormatActive(view, 'strikethrough'),
           },
         ],
       },
@@
           {
             icon: Code,
             title: '代码',
             shortcut: '⌘E',
             action: commands.inlineCode,
+            isActive: (view) => isInlineFormatActive(view, 'inlineCode'),
           },
         ],
       },
     ]
@@
     const executeCommand = (action: (view: EditorView) => void) => {
       if (props.editorView) {
         action(props.editorView)
         props.editorView.focus()
+        selectionVersion.value += 1
       }
     }
+
+    const updateSelectionState = () => {
+      selectionVersion.value += 1
+    }
+
+    const setupSelectionListeners = (view: EditorView | undefined) => {
+      if (!view) return
+
+      const handleMouseUp = () => updateSelectionState()
+      const handleKeyUp = (e: KeyboardEvent) => {
+        if (
+          e.key === 'Shift' ||
+          e.key.startsWith('Arrow') ||
+          e.ctrlKey ||
+          e.metaKey
+        ) {
+          updateSelectionState()
+        }
+      }
+      const handleMouseDown = () => updateSelectionState()
+
+      view.dom.addEventListener('mouseup', handleMouseUp)
+      view.dom.addEventListener('keyup', handleKeyUp)
+      view.dom.addEventListener('mousedown', handleMouseDown)
+
+      detachSelectionListeners = () => {
+        view.dom.removeEventListener('mouseup', handleMouseUp)
+        view.dom.removeEventListener('keyup', handleKeyUp)
+        view.dom.removeEventListener('mousedown', handleMouseDown)
+      }
+    }
+
+    watch(
+      () => props.editorView,
+      (view) => {
+        if (detachSelectionListeners) {
+          detachSelectionListeners()
+          detachSelectionListeners = null
+        }
+        setupSelectionListeners(view)
+        updateSelectionState()
+      },
+      { immediate: true },
+    )
+
+    onUnmounted(() => {
+      if (detachSelectionListeners) {
+        detachSelectionListeners()
+      }
+    })
@@
                       <button
                         key={button.title}
                         onClick={() => executeCommand(button.action)}
                         class={[
                           'group relative flex items-center justify-center',
                           'size-8 rounded-lg',
                           'text-neutral-500 dark:text-neutral-400',
                           'transition-all duration-150',
                           'hover:bg-neutral-100 dark:hover:bg-neutral-800',
                           'hover:text-neutral-900 dark:hover:text-neutral-100',
+                          selectionVersion.value && props.editorView
+                            ? button.isActive?.(props.editorView)
+                              ? 'bg-blue-50 text-blue-600 dark:bg-blue-900/40 dark:text-blue-200'
+                              : ''
+                            : '',
                           'active:scale-95',
                         ]}
                         aria-label={button.title}
                       >
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-23 09:36:56Z)**_

<think><details><summary>Thought Process</summary>
**Summarizing patch update effects**

The patch added a long import line with multiple entries and included a warning about apply_patch earlier. I'll highlight the active inline state and suggest possibly extending this approach to headings or lists if needed. Next, I'll check relevant files for applying these updates consistently.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-23 09:37:00Z)**_

已在工具栏和浮动工具栏增加“选中态”渲染，基于当前选区是否处于对应内联样式（粗体/斜体/删除线/行内代码）来切换 active 样式。

改动点  
- `src/components/editor/toolbar/toolbar.tsx`：监听选区变化触发重渲染；按钮支持 `isActive`；新增 `.is-active` 样式  
- `src/components/editor/toolbar/floating-toolbar.tsx`：同样加入选中态逻辑与高亮样式

如果你还想支持“标题/列表/引用”等块级样式的选中态，我可以继续补上判断逻辑。  
建议下一步：  
1) 在编辑器里选中已加粗文字，观察工具栏与浮动工具栏按钮是否高亮  
2) 告诉我是否需要扩展到标题/列表/引用等按钮
