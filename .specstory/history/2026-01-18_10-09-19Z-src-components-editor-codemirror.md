<!-- Generated by SpecStory, Markdown v2.1.0 -->

# 2026-01-18 10:10:52Z

<!-- Codex CLI Session 019bd094-9f14-76a0-b665-16e85185c5d7 (2026-01-18 10:10:52Z) -->

_**User (2026-01-18 10:10:52Z)**_

src/components/editor/codemirror 在 wysiwyg 下，编辑器首次加载内容的时候，没有对 inline block（比如 inline code、加粗等格式）以及块级的图片和代码块，呈现出“所见即所得”的形态

---

_**Agent (gpt-5.2-codex 2026-01-18 10:10:56Z)**_

<think><details><summary>Thought Process</summary>
**Preparing to inspect Vue files**

I'm planning to use ripgrep to search through the Vue files to understand the task requirements better.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-18 10:10:57Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: 986b55
Wall time: 0.0517 seconds
Process exited with code 0
Original token count: 37
Output:
src/components/editor/codemirror/codemirror.css
src/components/editor/codemirror/use-codemirror.ts
src/components/editor/codemirror/codemirror.tsx
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-18 10:11:00Z)**_

<think><details><summary>Thought Process</summary>
**Locating WYSIWYG view files**
</details></think>

_**Agent (gpt-5.2-codex 2026-01-18 10:11:00Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: 2f5047
Wall time: 0.0514 seconds
Process exited with code 0
Original token count: 1811
Output:
src/components/editor/codemirror/use-codemirror.ts:113:                general.setting.renderMode === 'wysiwyg' ? 'plain' : 'wysiwyg'
src/components/editor/codemirror/codemirror.tsx:17:import { codeBlockWysiwygExtension } from './wysiwyg-codeblock'
src/components/editor/codemirror/codemirror.tsx:18:import { dividerWysiwygExtension } from './wysiwyg-divider'
src/components/editor/codemirror/codemirror.tsx:19:import { headingWysiwygExtension } from './wysiwyg-heading'
src/components/editor/codemirror/codemirror.tsx:20:import { inlineWysiwygExtension } from './wysiwyg-inline'
src/components/editor/codemirror/codemirror.tsx:64:          (renderMode ?? 'plain') === 'wysiwyg'
src/components/editor/codemirror/codemirror.tsx:68:                ...inlineWysiwygExtension,
src/components/editor/codemirror/codemirror.tsx:75:            codemirrorReconfigureExtensionMap.wysiwyg.reconfigure(extensions),
src/components/editor/codemirror/wysiwyg-divider.ts:11:    wrapper.className = 'cm-wysiwyg-divider'
src/components/editor/codemirror/extension.ts:11:  wysiwyg: new Compartment(),
src/components/editor/codemirror/extension.ts:24:  extensionMap.wysiwyg.of([]),
src/components/editor/codemirror/wysiwyg-inline.ts:14:    span.className = 'cm-wysiwyg-hidden-marker'
src/components/editor/codemirror/wysiwyg-inline.ts:36:    span.className = 'cm-wysiwyg-link-url'
src/components/editor/codemirror/wysiwyg-inline.ts:51:// Image widget - shows image preview
src/components/editor/codemirror/wysiwyg-inline.ts:62:    wrapper.className = 'cm-wysiwyg-image-wrapper'
src/components/editor/codemirror/wysiwyg-inline.ts:67:    img.className = 'cm-wysiwyg-image'
src/components/editor/codemirror/wysiwyg-inline.ts:97:    span.className = 'cm-wysiwyg-inline-code'
src/components/editor/codemirror/wysiwyg-inline.ts:169:  // For images
src/components/editor/codemirror/wysiwyg-inline.ts:171:  imageAlt?: string
src/components/editor/codemirror/wysiwyg-inline.ts:172:  imageUrl?: string
src/components/editor/codemirror/wysiwyg-inline.ts:175:  // For inline code
src/components/editor/codemirror/wysiwyg-inline.ts:180:// Find all inline patterns in a line
src/components/editor/codemirror/wysiwyg-inline.ts:190:  const inlineCodeRegex = /`([^`]+)`/g
src/components/editor/codemirror/wysiwyg-inline.ts:191:  while ((match = inlineCodeRegex.exec(lineText)) !== null) {
src/components/editor/codemirror/wysiwyg-inline.ts:199:      className: 'cm-wysiwyg-inline-code',
src/components/editor/codemirror/wysiwyg-inline.ts:206:  const imageRegex = /!\[([^\]]*)\]\(([^)]+)\)/g
src/components/editor/codemirror/wysiwyg-inline.ts:207:  while ((match = imageRegex.exec(lineText)) !== null) {
src/components/editor/codemirror/wysiwyg-inline.ts:220:      className: 'cm-wysiwyg-image',
src/components/editor/codemirror/wysiwyg-inline.ts:222:      imageAlt: alt,
src/components/editor/codemirror/wysiwyg-inline.ts:223:      imageUrl: url,
src/components/editor/codemirror/wysiwyg-inline.ts:244:      className: 'cm-wysiwyg-bold',
src/components/editor/codemirror/wysiwyg-inline.ts:263:      className: 'cm-wysiwyg-strikethrough',
src/components/editor/codemirror/wysiwyg-inline.ts:267:  // Link: [text](url) - but not images
src/components/editor/codemirror/wysiwyg-inline.ts:285:      className: 'cm-wysiwyg-link',
src/components/editor/codemirror/wysiwyg-inline.ts:311:        className: 'cm-wysiwyg-italic',
src/components/editor/codemirror/wysiwyg-inline.ts:376:      // For images, use line-level cursor detection
src/components/editor/codemirror/wysiwyg-inline.ts:391:      } else if (match.isImage && match.imageUrl) {
src/components/editor/codemirror/wysiwyg-inline.ts:392:        // Replace entire image syntax with image widget
src/components/editor/codemirror/wysiwyg-inline.ts:395:            widget: new ImageWidget(match.imageAlt || '', match.imageUrl),
src/components/editor/codemirror/wysiwyg-inline.ts:399:        // Replace entire inline code with highlighted widget
src/components/editor/codemirror/wysiwyg-inline.ts:445:const inlineWysiwygPlugin = ViewPlugin.fromClass(
src/components/editor/codemirror/wysiwyg-inline.ts:468:export const inlineWysiwygExtension = [inlineWysiwygPlugin]
src/components/editor/codemirror/codemirror.css:29:  .cm-wysiwyg-divider {
src/components/editor/codemirror/codemirror.css:36:  .cm-wysiwyg-divider hr {
src/components/editor/codemirror/codemirror.css:43:  .cm-wysiwyg-heading-marker {
src/components/editor/codemirror/codemirror.css:47:  .cm-wysiwyg-heading {
src/components/editor/codemirror/codemirror.css:51:  .cm-wysiwyg-heading-1 {
src/components/editor/codemirror/codemirror.css:56:  .cm-wysiwyg-heading-2 {
src/components/editor/codemirror/codemirror.css:61:  .cm-wysiwyg-heading-3 {
src/components/editor/codemirror/codemirror.css:66:  .cm-wysiwyg-heading-4 {
src/components/editor/codemirror/codemirror.css:71:  .cm-wysiwyg-heading-5 {
src/components/editor/co
... (truncated)
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-18 10:11:02Z)**_

<think><details><summary>Thought Process</summary>
**Requesting open files for debugging**
</details></think>

_**Agent (gpt-5.2-codex 2026-01-18 10:11:03Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: 660b7f
Wall time: 0.0515 seconds
Process exited with code 0
Original token count: 851
Output:
/* eslint-disable vue/no-setup-props-destructure */
import { defineComponent } from 'vue'
import type { EditorState } from '@codemirror/state'
import type { PropType } from 'vue'

import { useSaveConfirm } from '~/hooks/use-save-confirm'

import { FloatingToolbar } from '../toolbar/floating-toolbar'
import { useSelectionPosition } from '../toolbar/use-selection-position'
import styles from '../universal/editor.module.css'
import { editorBaseProps } from '../universal/props'

import './codemirror.css'

import { codemirrorReconfigureExtensionMap } from './extension'
import { useCodeMirror } from './use-codemirror'
import { codeBlockWysiwygExtension } from './wysiwyg-codeblock'
import { dividerWysiwygExtension } from './wysiwyg-divider'
import { headingWysiwygExtension } from './wysiwyg-heading'
import { inlineWysiwygExtension } from './wysiwyg-inline'

export const CodemirrorEditor = defineComponent({
  name: 'CodemirrorEditor',
  props: {
    ...editorBaseProps,
    onStateChange: {
      type: Function as PropType<(state: EditorState) => void>,
      required: false,
    },
    className: {
      type: String,
    },
  },
  setup(props, { expose }) {
    const [refContainer, editorView] = useCodeMirror({
      initialDoc: props.text,
      onChange: (state) => {
        props.onChange(state.doc.toString())
        props.onStateChange?.(state)
      },
    })

    watch(
      () => props.text,
      (n) => {
        const editor = editorView.value

        if (editor && n != editor.state.doc.toString()) {
          editor.dispatch({
            changes: { from: 0, to: editor.state.doc.length, insert: n },
          })
        }
      },
    )

    watch(
      () => [props.renderMode, editorView.value],
      ([renderMode]) => {
        const view = editorView.value
        if (!view) return

        const hadFocus = view.hasFocus
        const extensions =
          (renderMode ?? 'plain') === 'wysiwyg'
            ? [
                ...dividerWysiwygExtension,
                ...headingWysiwygExtension,
                ...inlineWysiwygExtension,
                ...codeBlockWysiwygExtension,
              ]
            : []

        view.dispatch({
          effects:
            codemirrorReconfigureExtensionMap.wysiwyg.reconfigure(extensions),
        })

        if (hadFocus) {
          requestAnimationFrame(() => view.focus())
        }
      },
      {
        immediate: true,
        flush: 'post',
      },
    )

    expose({
      setValue: (value: string) => {
        const editor = editorView.value
        if (editor) {
          editor.dispatch({
            changes: { from: 0, to: editor.state.doc.length, insert: value },
          })
        }
      },
    })

    const memoedText = props.text

    useSaveConfirm(
      props.unSaveConfirm,
      () => memoedText === editorView.value?.state.doc.toString(),
    )

    // 浮动工具栏选区位置追踪
    const { position, hasSelection } = useSelectionPosition(editorView)

    return () => (
      <div class="relative flex h-full flex-col">
        <div
          class={[styles.editor, props.className, 'flex-1 overflow-auto']}
          ref={refContainer}
        />
        {/* 浮动工具栏 */}
        <FloatingToolbar
          editorView={editorView.value}
          visible={hasSelection.value}
          position={position.value}
        />
      </div>
    )
  },
})
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-18 10:11:06Z)**_

<think><details><summary>Thought Process</summary>
**Identifying component needs**

I'm noting the requirement for code implementations of use-codemirror, wysiwyg-inline, and codeblock components.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-18 10:11:06Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: 994273
Wall time: 0.0509 seconds
Process exited with code 0
Original token count: 1085
Output:
import { onMounted, ref } from 'vue'
import type { Ref } from 'vue'

import {
  defaultKeymap,
  history,
  historyKeymap,
  indentWithTab,
} from '@codemirror/commands'
import { markdownKeymap } from '@codemirror/lang-markdown'
import { bracketMatching, indentOnInput } from '@codemirror/language'
import { search, searchKeymap } from '@codemirror/search'
import { EditorState } from '@codemirror/state'
import {
  EditorView,
  highlightActiveLine,
  highlightActiveLineGutter,
  keymap,
  lineNumbers,
} from '@codemirror/view'

import { createToolbarKeymapExtension } from '../toolbar'
import { useEditorConfig } from '../universal/use-editor-setting'
import { codemirrorReconfigureExtension } from './extension'
import { syntaxTheme } from './syntax-highlight'
import { useCodeMirrorConfigureFonts } from './use-auto-fonts'
import { useCodeMirrorAutoToggleTheme } from './use-auto-theme'

interface Props {
  initialDoc: string
  onChange?: (state: EditorState) => void
}

export const useCodeMirror = <T extends Element>(
  props: Props,
): [Ref<T | undefined>, Ref<EditorView | undefined>] => {
  const refContainer = ref<T>()
  const editorView = ref<EditorView>()
  const { general } = useEditorConfig()
  const { onChange } = props

  const format = () => {
    const ev = editorView.value
    const autocorrect = general.setting.autocorrect

    if (autocorrect && ev) {
      import('@huacnlee/autocorrect')
        .then(({ formatFor }) => {
          const { state, dispatch } = ev
          const currentLine = state.doc.lineAt(state.selection.main.head)
          if (currentLine.text) {
            return
          }

          const allLineBeforeCurrentLine = state.doc.sliceString(
            0,
            currentLine.from,
          )
          const format = (text: string) => {
            return formatFor(text, 'cm.md').out as string
          }
          const newText = format(allLineBeforeCurrentLine)

          const delta = newText.length - allLineBeforeCurrentLine.length

          const afterCurrentLine = state.doc.sliceString(
            currentLine.to,
            state.doc.length,
          )
          const newAfterCurrentLine = format(afterCurrentLine)

          dispatch({
            changes: {
              from: 0,
              to: state.doc.length,
              insert: newText + newAfterCurrentLine,
            },
            selection: {
              anchor: state.selection.main.anchor + delta,
            },
          })
        })
        .catch(() => {
          // not support wasm
        })
    }
  }
  onMounted(() => {
    if (!refContainer.value) return

    const startState = EditorState.create({
      doc: props.initialDoc,
      extensions: [
        keymap.of([
          {
            key: 'Mod-s',
            run() {
              return false
            },
            preventDefault: true,
          },
          {
            key: 'Enter',
            run() {
              requestAnimationFrame(format)
              return false
            },
          },
          {
            key: 'Mod-/',
            run() {
              general.setting.renderMode =
                general.setting.renderMode === 'wysiwyg' ? 'plain' : 'wysiwyg'
              return true
            },
          },
        ]),
        createToolbarKeymapExtension(),
        keymap.of([
          ...defaultKeymap,
          ...historyKeymap,
          ...markdownKeymap,
          ...searchKeymap,
          indentWithTab,
        ]),

        lineNumbers(),
        highlightActiveLineGutter(),
        history(),
        indentOnInput(),
        bracketMatching(),
        highlightActiveLine(),
        EditorState.tabSize.of(2),
        search({
          top: true,
        }),

        syntaxTheme,

        ...codemirrorReconfigureExtension,

        EditorView.lineWrapping,
        EditorView.updateListener.of((update) => {
          if (update.changes) {
            onChange && onChange(update.state)
          }
        }),
      ],
    })

    const view = new EditorView({
      state: startState,
      parent: refContainer.value,
    })

    editorView.value = view
  })

  useCodeMirrorAutoToggleTheme(editorView)
  useCodeMirrorConfigureFonts(editorView)

  onBeforeUnmount(() => {
    editorView.value?.destroy()
  })

  return [refContainer, editorView]
}
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-18 10:11:11Z)**_

<think><details><summary>Thought Process</summary>
**Investigating initial WYSIWYG rendering issue**

I’m checking how the WYSIWYG inline and codeblock handle initial document decoration updates, suspecting the ViewPlugin’s update may not trigger correctly on initial load due to reliance on viewport or visibleRanges before view is attached to the DOM.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-18 10:11:11Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: ebad63
Wall time: 0.0513 seconds
Process exited with code 0
Original token count: 1650
Output:
import type { DecorationSet, EditorView } from '@codemirror/view'
import { Decoration, WidgetType, ViewPlugin } from '@codemirror/view'
import type { EditorState, Range } from '@codemirror/state'
import { codeToHtml } from 'shiki'

// Hidden marker widget - displays nothing
class HiddenMarkerWidget extends WidgetType {
  constructor(readonly marker: string) {
    super()
  }

  toDOM(): HTMLElement {
    const span = document.createElement('span')
    span.className = 'cm-wysiwyg-hidden-marker'
    span.textContent = this.marker
    return span
  }

  eq(other: HiddenMarkerWidget): boolean {
    return this.marker === other.marker
  }

  ignoreEvent(): boolean {
    return false
  }
}

// Link URL widget - shows a small link indicator
class LinkUrlWidget extends WidgetType {
  constructor(readonly url: string) {
    super()
  }

  toDOM(): HTMLElement {
    const span = document.createElement('span')
    span.className = 'cm-wysiwyg-link-url'
    span.textContent = `](${this.url})`
    span.title = this.url
    return span
  }

  eq(other: LinkUrlWidget): boolean {
    return this.url === other.url
  }

  ignoreEvent(): boolean {
    return false
  }
}

// Image widget - shows image preview
class ImageWidget extends WidgetType {
  constructor(
    readonly alt: string,
    readonly url: string,
  ) {
    super()
  }

  toDOM(): HTMLElement {
    const wrapper = document.createElement('span')
    wrapper.className = 'cm-wysiwyg-image-wrapper'

    const img = document.createElement('img')
    img.src = this.url
    img.alt = this.alt
    img.className = 'cm-wysiwyg-image'
    img.title = this.alt || this.url

    wrapper.appendChild(img)
    return wrapper
  }

  eq(other: ImageWidget): boolean {
    return this.url === other.url && this.alt === other.alt
  }

  ignoreEvent(): boolean {
    return false
  }
}

// Inline code widget with shiki highlighting
class InlineCodeWidget extends WidgetType {
  private static highlightCache = new Map<string, string>()
  private static pendingHighlights = new Map<string, Promise<string>>()

  constructor(
    readonly code: string,
    readonly isDark: boolean,
  ) {
    super()
  }

  toDOM(): HTMLElement {
    const span = document.createElement('span')
    span.className = 'cm-wysiwyg-inline-code'
    span.textContent = this.code

    // Try to get cached highlight
    const cacheKey = `${this.code}:${this.isDark}`
    const cached = InlineCodeWidget.highlightCache.get(cacheKey)
    if (cached) {
      span.innerHTML = cached
      return span
    }

    // Check if highlight is already pending
    const pending = InlineCodeWidget.pendingHighlights.get(cacheKey)
    if (pending) {
      pending.then((html) => {
        if (span.isConnected) {
          span.innerHTML = html
        }
      })
      return span
    }

    // Start async highlight
    const highlightPromise = this.highlight()
    InlineCodeWidget.pendingHighlights.set(cacheKey, highlightPromise)

    highlightPromise.then((html) => {
      InlineCodeWidget.highlightCache.set(cacheKey, html)
      InlineCodeWidget.pendingHighlights.delete(cacheKey)
      if (span.isConnected) {
        span.innerHTML = html
      }
    })

    return span
  }

  private async highlight(): Promise<string> {
    try {
      const html = await codeToHtml(this.code, {
        lang: 'text',
        theme: this.isDark ? 'github-dark' : 'github-light',
      })
      // Extract just the code content, remove pre/code wrappers
      const match = html.match(/<code[^>]*>([\s\S]*?)<\/code>/)
      return match ? match[1] : this.code
    } catch {
      return this.code
    }
  }

  eq(other: InlineCodeWidget): boolean {
    return this.code === other.code && this.isDark === other.isDark
  }

  ignoreEvent(): boolean {
    return false
  }
}

interface InlineMatch {
  start: number
  end: number
  markerStart: string
  markerEnd: string
  contentStart: number
  contentEnd: number
  className: string
  // For links
  linkUrl?: string
  linkUrlStart?: number
  linkUrlEnd?: number
  // For images
  isImage?: boolean
  imageAlt?: string
  imageUrl?: string
  lineFrom?: number
  lineTo?: number
  // For inline code
  isInlineCode?: boolean
  codeContent?: string
}

// Find all inline patterns in a line
const findInlinePatterns = (
  lineText: string,
  lineFrom: number,
  lineTo: number,
): InlineMatch[] => {
  const matches: InlineMatch[] = []
  let match: RegExpExecArray | null

  // Inline code: `code` (must be before other patterns to avoid conflicts)
  const inlineCodeRegex = /`([^`]+)`/g
  while ((match = inlineCodeRegex.exec(lineText)) !== null) {
    matches.push({
      start: lineFrom + match.index,
      end: lineFrom + match.index + match[0].length,
      markerStart: '`',
      markerEnd: '`',
      contentStart: lineFrom + match.index + 1,
      contentEnd: lineFrom + match.index + match[0].length - 1,
      className: 
... (truncated)
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-18 10:11:14Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: 800038
Wall time: 0.0525 seconds
Process exited with code 0
Original token count: 1509
Output:
      markerEnd: '~~',
      contentStart: matchStart + 2,
      contentEnd: matchEnd - 2,
      className: 'cm-wysiwyg-strikethrough',
    })
  }

  // Link: [text](url) - but not images
  const linkRegex = /(?<!!)\[([^\]]+)\]\(([^)]+)\)/g
  while ((match = linkRegex.exec(lineText)) !== null) {
    const fullMatch = match[0]
    const text = match[1]
    const url = match[2]
    const matchStart = lineFrom + match.index

    if (isOverlapping(matches, matchStart, matchStart + fullMatch.length))
      continue

    matches.push({
      start: matchStart,
      end: matchStart + fullMatch.length,
      markerStart: '[',
      markerEnd: ']',
      contentStart: matchStart + 1,
      contentEnd: matchStart + 1 + text.length,
      className: 'cm-wysiwyg-link',
      linkUrl: url,
      linkUrlStart: matchStart + 1 + text.length,
      linkUrlEnd: matchStart + fullMatch.length,
    })
  }

  // Italic: *text* or _text_ (but not ** or __)
  const italicRegex =
    /(?<!\*)\*(?!\*)(?!\s)([^*]+?)(?<!\s)\*(?!\*)|(?<!_)_(?!_)(?!\s)([^_]+?)(?<!\s)_(?!_)/g
  while ((match = italicRegex.exec(lineText)) !== null) {
    const marker = match[0].startsWith('*') ? '*' : '_'
    const content = match[1] || match[2]
    const matchStart = lineFrom + match.index
    const matchEnd = matchStart + match[0].length

    if (isOverlapping(matches, matchStart, matchEnd)) continue

    if (content) {
      matches.push({
        start: matchStart,
        end: matchEnd,
        markerStart: marker,
        markerEnd: marker,
        contentStart: matchStart + 1,
        contentEnd: matchEnd - 1,
        className: 'cm-wysiwyg-italic',
      })
    }
  }

  return matches.sort((a, b) => a.start - b.start)
}

// Check if a range overlaps with existing matches
const isOverlapping = (
  matches: InlineMatch[],
  start: number,
  end: number,
): boolean => {
  return matches.some(
    (m) =>
      (start >= m.start && start < m.end) || (end > m.start && end <= m.end),
  )
}

// Cache for hidden marker widgets
const hiddenMarkerCache = new Map<string, HiddenMarkerWidget>()
const getHiddenMarker = (marker: string): HiddenMarkerWidget => {
  let widget = hiddenMarkerCache.get(marker)
  if (!widget) {
    widget = new HiddenMarkerWidget(marker)
    hiddenMarkerCache.set(marker, widget)
  }
  return widget
}

// Check if cursor is within a range
const isCursorInRange = (
  state: EditorState,
  start: number,
  end: number,
): boolean => {
  const { from, to } = state.selection.main
  return from < end && to > start
}

// Check if cursor is on a line
const isCursorOnLine = (
  state: EditorState,
  lineFrom: number,
  lineTo: number,
): boolean => {
  const { from, to } = state.selection.main
  return from <= lineTo && to >= lineFrom
}

// Detect dark mode
const isDarkMode = (): boolean => {
  return document.documentElement.classList.contains('dark')
}

const buildInlineDecorations = (state: EditorState): DecorationSet => {
  const decorations: Range<Decoration>[] = []
  const dark = isDarkMode()

  for (let lineNumber = 1; lineNumber <= state.doc.lines; lineNumber++) {
    const line = state.doc.line(lineNumber)
    const matches = findInlinePatterns(line.text, line.from, line.to)

    for (const match of matches) {
      // For images, use line-level cursor detection
      const cursorInMatch = match.isImage
        ? isCursorOnLine(state, match.lineFrom!, match.lineTo!)
        : isCursorInRange(state, match.start, match.end)

      if (cursorInMatch) {
        // Only apply the style, don't hide markers
        if (!match.isImage) {
          decorations.push(
            Decoration.mark({ class: match.className }).range(
              match.contentStart,
              match.contentEnd,
            ),
          )
        }
      } else if (match.isImage && match.imageUrl) {
        // Replace entire image syntax with image widget
        decorations.push(
          Decoration.replace({
            widget: new ImageWidget(match.imageAlt || '', match.imageUrl),
          }).range(match.start, match.end),
        )
      } else if (match.isInlineCode && match.codeContent) {
        // Replace entire inline code with highlighted widget
        decorations.push(
          Decoration.replace({
            widget: new InlineCodeWidget(match.codeContent, dark),
          }).range(match.start, match.end),
        )
      } else {
        // Hide start marker
        decorations.push(
          Decoration.replace({
            widget: getHiddenMarker(match.markerStart),
          }).range(match.start, match.contentStart),
        )

        // Style the content
        decorations.push(
          Decoration.mark({ class: match.className }).range(
            match.contentStart,
            match.contentEnd,
          ),
        )

        // For links, handle the URL part specially
        if (match.linkUrl && match.linkUrlStart !== undefined) 
... (truncated)
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-18 10:11:25Z)**_

<think><details><summary>Thought Process</summary>
**Investigating initial extension reconfiguration**

Noticing that inline decorations aren't applied on initial load suggests the plugin might not activate until after the view is created and updated; the reconfigure logic watching renderMode and editorView should trigger, but the extension's reconfigure handling may have issues applying decorations initially. I'll check the extension reconfiguration code for possible gaps on first render.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-18 10:11:26Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: 7551d7
Wall time: 0.0504 seconds
Process exited with code 0
Original token count: 181
Output:
import type { Extension } from '@codemirror/state'

import { markdown, markdownLanguage } from '@codemirror/lang-markdown'
import { languages } from '@codemirror/language-data'
import { Compartment } from '@codemirror/state'

const extensionMap = {
  theme: new Compartment(),
  language: new Compartment(),
  fonts: new Compartment(),
  wysiwyg: new Compartment(),
}

export const codemirrorReconfigureExtension: Extension[] = [
  extensionMap.theme.of([]),
  extensionMap.language.of(
    markdown({
      base: markdownLanguage,
      codeLanguages: languages,
      addKeymap: true,
    }),
  ),
  extensionMap.fonts.of([]),
  extensionMap.wysiwyg.of([]),
]

export { extensionMap as codemirrorReconfigureExtensionMap }
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-18 10:11:32Z)**_

<think><details><summary>Thought Process</summary>
**Investigating renderMode reconfiguration timing**

I'm verifying how the renderMode watch triggers extension setup since it runs after the editor view is created on mount; potential async timing or initial render nuances may affect proper extension inclusion. Next, I'll search the project for usage of renderMode to clarify its update flow.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-18 10:11:32Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: 2a88f9
Wall time: 0.0516 seconds
Process exited with code 0
Original token count: 329
Output:
src/components/editor/write-editor/index.tsx:127:        props.renderMode ?? generalSetting.renderMode ?? 'plain'
src/components/editor/write-editor/index.tsx:163:                renderMode={resolvedRenderMode}
src/components/editor/universal/editor-config.ts:14:  renderMode: 'plain' | 'wysiwyg' = 'plain'
src/components/editor/universal/props.ts:13:  renderMode: {
src/components/editor/universal/use-editor-setting.tsx:58:            value={generalSetting.renderMode}
src/components/editor/universal/use-editor-setting.tsx:61:              void (generalSetting.renderMode = e as 'plain' | 'wysiwyg')
src/components/editor/universal/index.tsx:100:        props.renderMode ?? generalSetting.renderMode ?? 'plain'
src/components/editor/universal/index.tsx:117:            renderMode={resolvedRenderMode}
src/components/editor/codemirror/codemirror.tsx:57:      () => [props.renderMode, editorView.value],
src/components/editor/codemirror/codemirror.tsx:58:      ([renderMode]) => {
src/components/editor/codemirror/codemirror.tsx:64:          (renderMode ?? 'plain') === 'wysiwyg'
src/components/editor/codemirror/use-codemirror.ts:112:              general.setting.renderMode =
src/components/editor/codemirror/use-codemirror.ts:113:                general.setting.renderMode === 'wysiwyg' ? 'plain' : 'wysiwyg'
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-18 10:11:35Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: e771a9
Wall time: 0.0514 seconds
Process exited with code 0
Original token count: 601
Output:
            onUpdateShow={handleUpdateShow}
          >
            <NCard
              closable
              onClose={handleModalClose}
              title="编辑器设定"
              style="max-width: 90vw;width: 500px; max-height: 65vh; overflow: auto"
              bordered={false}
            >
              <NForm labelPlacement="left" labelWidth="8rem" labelAlign="right">
                <GeneralSetting />
              </NForm>
            </NCard>
          </NModal>
        )
      },
    })

    const cmRef = ref<EditorRef>()

    expose({
      setValue: (value: string) => {
        cmRef.value?.setValue(value)
      },
    })

    // 计算副标题内容
    const subtitleContent = computed(() => {
      if (typeof props.subtitleSlot === 'function') {
        return props.subtitleSlot()
      }
      return props.subtitleSlot || slots.subtitle?.()
    })

    return () => {
      const { setting: generalSetting } = general
      const resolvedRenderMode =
        props.renderMode ?? generalSetting.renderMode ?? 'plain'
      return (
        <NElement
          tag="div"
          style={
            {
              '--editor-font-size': generalSetting.fontSize
                ? `${generalSetting.fontSize / 14}rem`
                : '',
              '--editor-font-family': generalSetting.fontFamily,
            } as any
          }
          class="write-editor-wrapper"
        >
          <div ref={scrollContainerRef} class="write-editor-scroll-container">
            {/* Title 区域 */}
            <div class="write-editor-header">
              <GhostInput
                value={props.title}
                onChange={props.onTitleChange}
                placeholder={props.titlePlaceholder}
              />

              {/* 副标题/Slug 区域 */}
              {subtitleContent.value && (
                <div class="write-editor-subtitle">{subtitleContent.value}</div>
              )}
            </div>

            {/* 编辑器区域 */}
            <div class="write-editor-content">
              <CodemirrorEditor
                ref={cmRef}
                text={props.text}
                onChange={props.onChange}
                unSaveConfirm={props.unSaveConfirm}
                renderMode={resolvedRenderMode}
              />
            </div>
          </div>

          <Modal />
        </NElement>
      )
    }
  },
})
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-18 10:12:07Z)**_

<think><details><summary>Thought Process</summary>
**Analyzing initial WYSIWYG render issue**

The initial WYSIWYG content isn't showing because the editor view is undefined on the first watch run, so the reactive watch skips updating; however, once the editorView is assigned, the watch should trigger again due to dependencies changing, but there's uncertainty if the current setup ensures that reactivity triggers as expected after mount.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-18 10:12:07Z)**_

<think><details><summary>Thought Process</summary>
**Pinpointing WYSIWYG plugin update timing**

The WYSIWYG decorations likely don't appear initially because the plugin is added after mount and initial empty doc setup, so when content loads asynchronously and updates the doc, the plugin should react but may miss applying decorations immediately; the plugin’s reliance on docChanged or selectionSet might delay rendering until further interaction or toggling.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-18 10:12:07Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: 779f98
Wall time: 0.0521 seconds
Process exited with code 0
Original token count: 1733
Output:
import type { DecorationSet, EditorView } from '@codemirror/view'
import { Decoration, WidgetType, ViewPlugin } from '@codemirror/view'
import type { EditorState, Range } from '@codemirror/state'
import { codeToHtml } from 'shiki'

// Widget for code block with shiki highlighting
class CodeBlockWidget extends WidgetType {
  private static highlightCache = new Map<string, string>()
  private static pendingHighlights = new Map<string, Promise<string>>()

  constructor(
    readonly code: string,
    readonly language: string,
    readonly isDark: boolean,
  ) {
    super()
  }

  toDOM(): HTMLElement {
    const wrapper = document.createElement('div')
    wrapper.className = 'cm-wysiwyg-codeblock'

    // Language label
    if (this.language) {
      const langLabel = document.createElement('div')
      langLabel.className = 'cm-wysiwyg-codeblock-lang'
      langLabel.textContent = this.language
      wrapper.appendChild(langLabel)
    }

    // Code container
    const codeContainer = document.createElement('div')
    codeContainer.className = 'cm-wysiwyg-codeblock-content'
    codeContainer.textContent = this.code
    wrapper.appendChild(codeContainer)

    // Try to get cached highlight
    const cacheKey = `${this.language}:${this.isDark}:${this.code}`
    const cached = CodeBlockWidget.highlightCache.get(cacheKey)
    if (cached) {
      codeContainer.innerHTML = cached
      return wrapper
    }

    // Check if highlight is already pending
    const pending = CodeBlockWidget.pendingHighlights.get(cacheKey)
    if (pending) {
      pending.then((html) => {
        if (codeContainer.isConnected) {
          codeContainer.innerHTML = html
        }
      })
      return wrapper
    }

    // Start async highlight
    const highlightPromise = this.highlight()
    CodeBlockWidget.pendingHighlights.set(cacheKey, highlightPromise)

    highlightPromise.then((html) => {
      CodeBlockWidget.highlightCache.set(cacheKey, html)
      CodeBlockWidget.pendingHighlights.delete(cacheKey)
      if (codeContainer.isConnected) {
        codeContainer.innerHTML = html
      }
    })

    return wrapper
  }

  private async highlight(): Promise<string> {
    try {
      // Map common language aliases
      const langMap: Record<string, string> = {
        js: 'javascript',
        ts: 'typescript',
        tsx: 'tsx',
        jsx: 'jsx',
        py: 'python',
        rb: 'ruby',
        sh: 'bash',
        shell: 'bash',
        yml: 'yaml',
        md: 'markdown',
      }

      const lang = langMap[this.language] || this.language || 'text'

      const html = await codeToHtml(this.code, {
        lang,
        theme: this.isDark ? 'github-dark' : 'github-light',
      })

      // Extract just the code content from shiki's output
      // shiki outputs: <pre class="..." style="..."><code>...</code></pre>
      const match = html.match(/<code[^>]*>([\s\S]*?)<\/code>/)
      return match ? match[1] : this.escapeHtml(this.code)
    } catch {
      // If language is not supported, return escaped plain text
      return this.escapeHtml(this.code)
    }
  }

  private escapeHtml(text: string): string {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/\n/g, '<br>')
  }

  eq(other: CodeBlockWidget): boolean {
    return (
      this.code === other.code &&
      this.language === other.language &&
      this.isDark === other.isDark
    )
  }

  ignoreEvent(): boolean {
    return false
  }
}

interface CodeBlock {
  startLine: number
  endLine: number
  language: string
  code: string
  startFrom: number
  endTo: number
}

// Find all code blocks in the document
const findCodeBlocks = (state: EditorState): CodeBlock[] => {
  const blocks: CodeBlock[] = []
  const codeBlockStartRegex = /^```(\w*)$/
  const codeBlockEndRegex = /^```$/

  let inCodeBlock = false
  let currentBlock: Partial<CodeBlock> & { codeLines?: string[] } = {}

  for (let lineNumber = 1; lineNumber <= state.doc.lines; lineNumber++) {
    const line = state.doc.line(lineNumber)

    if (!inCodeBlock) {
      const startMatch = codeBlockStartRegex.exec(line.text)
      if (startMatch) {
        inCodeBlock = true
        currentBlock = {
          startLine: lineNumber,
          language: startMatch[1] || '',
          startFrom: line.from,
          codeLines: [],
        }
      }
    } else {
      if (codeBlockEndRegex.test(line.text)) {
        blocks.push({
          startLine: currentBlock.startLine!,
          endLine: lineNumber,
          language: currentBlock.language!,
          code: currentBlock.codeLines!.join('\n'),
          startFrom: currentBlock.startFrom!,
          endTo: line.to,
        })
        inCodeBlock = false
        currentBlock = {}
      } else {
        currentBlock.codeLines!.push(line.text)
      }
    }
  }

  return blocks
}

// Check if cursor i
... (truncated)
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-18 10:12:25Z)**_

<think><details><summary>Thought Process</summary>
**Diagnosing initial WYSIWYG rendering issue**

The initial editor load may not display inline blocks and images in WYSIWYG because decorations aren't applied until a selection or document change triggers them, possibly due to reconfiguration running before the editor view is fully ready.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-18 10:12:25Z)**_

<think><details><summary>Thought Process</summary>
**Verifying editor reconfiguration and CSS loading**

The code watches render mode and editor view correctly, triggering reconfiguration, so the WYSIWYG extension dispatch should run after mounting; the issue may lie in CSS not applying initially or decorations depending on DOM state not ready when the plugin runs.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-18 10:12:25Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: d83586
Wall time: 0.0526 seconds
Process exited with code 0
Original token count: 891
Output:
.cm-editor {
  @apply bg-transparent;

  & .cm-gutters {
    @apply bg-transparent;
  }

  & {
    @apply h-full;
  }

  .cm-editor {
    .cm-gutters,
    .cm-activeLineGutter,
    .cm-activeLine {
      @apply transition-colors duration-500;
    }
  }

  &.cm-focused {
    @apply !outline-none;
  }

  & .cm-gutters,
  & .cm-gutter {
    @apply !min-w-[3rem];
  }

  .cm-wysiwyg-divider {
    display: block;
    width: 100%;
    padding: 0.5rem 0;
    opacity: 0.6;
  }

  .cm-wysiwyg-divider hr {
    border: 0;
    border-top: 1px solid currentColor;
    margin: 0;
  }

  /* Heading WYSIWYG styles */
  .cm-wysiwyg-heading-marker {
    display: none;
  }

  .cm-wysiwyg-heading {
    font-weight: 600;
  }

  .cm-wysiwyg-heading-1 {
    font-size: 2em;
    line-height: 1.3;
  }

  .cm-wysiwyg-heading-2 {
    font-size: 1.5em;
    line-height: 1.35;
  }

  .cm-wysiwyg-heading-3 {
    font-size: 1.25em;
    line-height: 1.4;
  }

  .cm-wysiwyg-heading-4 {
    font-size: 1.125em;
    line-height: 1.45;
  }

  .cm-wysiwyg-heading-5 {
    font-size: 1em;
    line-height: 1.5;
  }

  .cm-wysiwyg-heading-6 {
    font-size: 0.875em;
    line-height: 1.5;
    opacity: 0.85;
  }

  /* Inline WYSIWYG styles */
  .cm-wysiwyg-hidden-marker {
    display: none;
  }

  .cm-wysiwyg-bold {
    font-weight: 700;
  }

  .cm-wysiwyg-italic {
    font-style: italic;
  }

  .cm-wysiwyg-strikethrough {
    text-decoration: line-through;
    opacity: 0.7;
  }

  .cm-wysiwyg-link {
    color: var(--primary-default);
    text-decoration: underline;
    text-underline-offset: 2px;
  }

  .cm-wysiwyg-link-url {
    display: none;
  }

  /* Inline code styles */
  .cm-wysiwyg-inline-code {
    font-family: ui-monospace, SFMono-Regular, 'SF Mono', Menlo, Consolas,
      'Liberation Mono', monospace;
    font-size: 0.9em;
    padding: 0.125em 0.375em;
    border-radius: 0.25rem;
    background-color: color-mix(in srgb, currentColor 10%, transparent);
  }

  /* Image styles */
  .cm-wysiwyg-image-wrapper {
    display: inline-block;
    vertical-align: middle;
  }

  .cm-wysiwyg-image {
    max-width: 100%;
    max-height: 300px;
    border-radius: 0.375rem;
    object-fit: contain;
  }

  /* Code block styles - editing mode */
  .cm-wysiwyg-codeblock-line {
    font-family: ui-monospace, SFMono-Regular, 'SF Mono', Menlo, Consolas,
      'Liberation Mono', monospace;
    font-size: 0.9em;
    background-color: color-mix(in srgb, currentColor 5%, transparent);
  }

  .cm-wysiwyg-codeblock-editing {
    background-color: color-mix(in srgb, currentColor 8%, transparent);
  }

  /* Code block widget - display mode */
  .cm-wysiwyg-codeblock {
    display: block;
    margin: 0.5rem 0;
    border-radius: 0.5rem;
    overflow: hidden;
    background-color: color-mix(in srgb, currentColor 5%, transparent);
  }

  .cm-wysiwyg-codeblock-lang {
    display: block;
    font-family: ui-monospace, SFMono-Regular, 'SF Mono', Menlo, Consolas,
      'Liberation Mono', monospace;
    font-size: 0.75em;
    padding: 0.375rem 0.75rem;
    background-color: color-mix(in srgb, currentColor 8%, transparent);
    color: currentColor;
    opacity: 0.7;
    border-bottom: 1px solid color-mix(in srgb, currentColor 10%, transparent);
  }

  .cm-wysiwyg-codeblock-content {
    font-family: ui-monospace, SFMono-Regular, 'SF Mono', Menlo, Consolas,
      'Liberation Mono', monospace;
    font-size: 0.9em;
    padding: 0.75rem;
    overflow-x: auto;
    white-space: pre;
    line-height: 1.5;
  }

  .cm-wysiwyg-codeblock-content .line {
    display: block;
  }
}
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-18 10:12:30Z)**_

<think><details><summary>Thought Process</summary>
**Inspecting renderMode loading timing**

I'm checking if the renderMode setting loads asynchronously from local storage via use-editor-setting, which could cause initial renders to default to 'plain' before the correct mode is applied. This may explain missing WYSIWYG decorations initially.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-18 10:12:30Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: fc2fcd
Wall time: 0.0514 seconds
Process exited with code 0
Original token count: 526
Output:
import {
  NFormItem,
  NH5,
  NInput,
  NInputNumber,
  NSelect,
  NSwitch,
} from 'naive-ui'

import { useStorageObject } from '~/hooks/use-storage'

import { GeneralSettingDto } from './editor-config'
import { ResetIconButton } from './reset-icon-button'

const StorageKeys = {
  editor: 'editor-pref',
  general: 'editor-general',
} as const
export const useEditorConfig = () => {
  const {
    storage: generalSetting,
    reset: resetGeneralSetting,
    destory: generalDestory,
  } = useStorageObject(GeneralSettingDto, StorageKeys.general)

  const destory = () => {
    generalDestory()
  }

  const GeneralSetting = defineComponent(() => {
    return () => (
      <Fragment>
        <NH5 class="!mt-0 !flex items-center">
          通用设置
          <ResetIconButton resetFn={resetGeneralSetting} />
        </NH5>
        <NFormItem label="字体设定">
          <NInput
            onInput={(e) => void (generalSetting.fontFamily = e)}
            value={generalSetting.fontFamily}
          />
        </NFormItem>
        <NFormItem label="字号设定">
          <NInputNumber
            onUpdateValue={(e) => void (generalSetting.fontSize = e ?? 14)}
            value={generalSetting.fontSize}
          />
        </NFormItem>

        <NFormItem label="自动纠正标点">
          <NSwitch
            value={generalSetting.autocorrect}
            onUpdateValue={(e) => void (generalSetting.autocorrect = e)}
          />
        </NFormItem>
        <NFormItem label="渲染模式">
          <NSelect
            value={generalSetting.renderMode}
            to="body"
            onUpdateValue={(e) =>
              void (generalSetting.renderMode = e as 'plain' | 'wysiwyg')
            }
            options={[
              { label: '普通模式', value: 'plain' },
              { label: '所见即所得', value: 'wysiwyg' },
            ]}
          />
        </NFormItem>
      </Fragment>
    )
  })

  return {
    general: {
      setting: generalSetting,
      resetSetting: resetGeneralSetting,
      Panel: GeneralSetting,
    },

    destory,
  }
}
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-18 10:12:34Z)**_

<think><details><summary>Thought Process</summary>
**Inspecting storage defaults**

I'm checking useStorageObject and GeneralSettingDto to confirm where default storage values originate.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-18 10:12:35Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: 44c211
Wall time: 0.0507 seconds
Process exited with code 0
Original token count: 119
Output:
import { IsBoolean, IsInt, IsString, IsIn } from 'class-validator'

export class GeneralSettingDto {
  @IsInt()
  fontSize = 14

  @IsString()
  fontFamily =
    '"Helvetica Neue","Luxi Sans","DejaVu Sans","Hiragino Sans GB","Microsoft Yahei",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji","Segoe UI Symbol","Android Emoji","EmojiSymbols"'
  @IsBoolean()
  autocorrect = false

  @IsIn(['plain', 'wysiwyg'])
  renderMode: 'plain' | 'wysiwyg' = 'plain'
}
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-18 10:13:03Z)**_

<think><details><summary>Thought Process</summary>
**Analyzing renderMode and focus impact**

The renderMode updates reactively from storage, so WYSIWYG should apply after loading, but the editor likely starts unfocused—which may affect extension updates relying on focus to trigger display changes.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-18 10:13:03Z)**_

<think><details><summary>Thought Process</summary>
**Investigating decoration timing and extension reconfiguration**

The WYSIWYG plugin should reconfigure reactively when the editor view initializes, but initial document dispatch may conflict with decoration setup; also, inline widgets relying on async rendering might delay display, and block-level content may need different decoration handling to show properly on load.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-18 10:13:03Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: bfe531
Wall time: 0.0515 seconds
Process exited with code 0
Original token count: 368
Output:
import type { DecorationSet } from '@codemirror/view'
import { Decoration, EditorView, WidgetType } from '@codemirror/view'
import { RangeSetBuilder, StateField } from '@codemirror/state'
import type { EditorState } from '@codemirror/state'

const dividerPattern = /^-{3,}\s*$/

class DividerWidget extends WidgetType {
  toDOM(_view: EditorView): HTMLElement {
    const wrapper = document.createElement('div')
    wrapper.className = 'cm-wysiwyg-divider'

    const line = document.createElement('hr')
    wrapper.appendChild(line)

    return wrapper
  }

  ignoreEvent(): boolean {
    return false
  }
}

const dividerWidget = new DividerWidget()

const buildDividerDecorations = (state: EditorState): DecorationSet => {
  const builder = new RangeSetBuilder<Decoration>()

  for (let lineNumber = 1; lineNumber <= state.doc.lines; lineNumber++) {
    const line = state.doc.line(lineNumber)
    if (dividerPattern.test(line.text)) {
      builder.add(
        line.from,
        line.to,
        Decoration.replace({ widget: dividerWidget, block: true }),
      )
    }
  }

  return builder.finish()
}

const dividerWysiwygField = StateField.define<DecorationSet>({
  create(state) {
    return buildDividerDecorations(state)
  },
  update(value, tr) {
    if (!tr.docChanged) return value
    return buildDividerDecorations(tr.state)
  },
  provide: (field) => EditorView.decorations.from(field),
})

export const dividerWysiwygExtension = [dividerWysiwygField]
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-18 10:13:05Z)**_

<think><details><summary>Thought Process</summary>
**Noting divider state management**
</details></think>

_**Agent (gpt-5.2-codex 2026-01-18 10:13:06Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: 2b1e47
Wall time: 0.0506 seconds
Process exited with code 0
Original token count: 763
Output:
import type { DecorationSet, EditorView } from '@codemirror/view'
import { Decoration, WidgetType, ViewPlugin } from '@codemirror/view'
import type { EditorState, Range } from '@codemirror/state'

// Match heading lines: # to ###### followed by space and content
const headingPattern = /^(#{1,6})\s+(.+)$/

// Placeholder widget to replace the # symbols
class HeadingMarkerWidget extends WidgetType {
  constructor(readonly level: number) {
    super()
  }

  toDOM(): HTMLElement {
    const span = document.createElement('span')
    span.className = 'cm-wysiwyg-heading-marker'
    span.textContent = '#'.repeat(this.level) + ' '
    return span
  }

  eq(other: HeadingMarkerWidget): boolean {
    return this.level === other.level
  }

  ignoreEvent(): boolean {
    return false
  }
}

// Cache widgets for each level
const headingMarkerWidgets = Array.from(
  { length: 6 },
  (_, i) => new HeadingMarkerWidget(i + 1),
)

// Line decoration for each heading level
const headingLineDecorations = Array.from({ length: 6 }, (_, i) =>
  Decoration.line({ class: `cm-wysiwyg-heading cm-wysiwyg-heading-${i + 1}` }),
)

// Check if cursor is on a specific line
const isCursorOnLine = (state: EditorState, lineFrom: number, lineTo: number): boolean => {
  const { from, to } = state.selection.main
  return from <= lineTo && to >= lineFrom
}

const buildHeadingDecorations = (state: EditorState): DecorationSet => {
  const decorations: Range<Decoration>[] = []

  for (let lineNumber = 1; lineNumber <= state.doc.lines; lineNumber++) {
    const line = state.doc.line(lineNumber)
    const match = headingPattern.exec(line.text)

    if (match) {
      const level = match[1].length
      const markerLength = level + 1 // # symbols + space

      // Add line decoration for styling the entire line
      decorations.push(headingLineDecorations[level - 1].range(line.from))

      // Check if cursor is on this line
      const cursorOnLine = isCursorOnLine(state, line.from, line.to)

      // Only hide markers if cursor is NOT on this line
      if (!cursorOnLine) {
        decorations.push(
          Decoration.replace({ widget: headingMarkerWidgets[level - 1] }).range(
            line.from,
            line.from + markerLength,
          ),
        )
      }
    }
  }

  // Sort decorations by position
  decorations.sort((a, b) => a.from - b.from || a.to - b.to)

  return Decoration.set(decorations)
}

// Use ViewPlugin to react to selection changes
const headingWysiwygPlugin = ViewPlugin.fromClass(
  class {
    decorations: DecorationSet

    constructor(view: EditorView) {
      this.decorations = buildHeadingDecorations(view.state)
    }

    update(update: { docChanged: boolean; selectionSet: boolean; state: EditorState }) {
      // Rebuild on doc change OR selection change
      if (update.docChanged || update.selectionSet) {
        this.decorations = buildHeadingDecorations(update.state)
      }
    }
  },
  {
    decorations: (v) => v.decorations,
  },
)

export const headingWysiwygExtension = [headingWysiwygPlugin]
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-18 10:13:38Z)**_

<think><details><summary>Thought Process</summary>
**Spotting missing imported watcher**

Noticed `watch` is used but not explicitly imported from Vue, which might cause reactive updates for the view plugin to fail or behave unexpectedly. Next, I'll verify if `watch` is globally available or needs an explicit import to fix update handling.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-18 10:13:38Z)**_

<think><details><summary>Thought Process</summary>
**Confirming auto-imports and exploring rendering issues**

Verified `watch` and `onBeforeUnmount` are likely auto-imported, so missing imports aren't the issue. I'm exploring whether decoration application, CSS nesting for hidden markers, or extension reconfiguration order during initial load causes WYSIWYG not to appear correctly. Next, I'll inspect related theme and font configuration hooks that might interfere.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-18 10:13:38Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: de66e3
Wall time: 0.0514 seconds
Process exited with code 0
Original token count: 251
Output:
import type { EditorView } from '@codemirror/view/dist'
import type { Ref } from 'vue'

import { oneDark } from '@codemirror/theme-one-dark'
import { githubLight } from '@ddietr/codemirror-themes/theme/github-light'

import { useStoreRef } from '~/hooks/use-store-ref'
import { UIStore } from '~/stores/ui'

import { codemirrorReconfigureExtensionMap } from './extension'

export const useCodeMirrorAutoToggleTheme = (
  view: Ref<EditorView | undefined>,
) => {
  const { isDark } = useStoreRef(UIStore)
  watch(
    [isDark, view],
    ([isDark]) => {
      if (!view.value) {
        return
      }

      if (isDark) {
        view.value.dispatch({
          effects: [
            codemirrorReconfigureExtensionMap.theme.reconfigure(oneDark),
          ],
        })
      } else {
        view.value.dispatch({
          effects: [
            codemirrorReconfigureExtensionMap.theme.reconfigure(githubLight),
          ],
        })
      }
    },

    { immediate: true, flush: 'post' },
  )
}
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-18 10:15:51Z)**_

<think><details><summary>Thought Process</summary>
**Reviewing theme reconfiguration and font usage**
</details></think>

_**Agent (gpt-5.2-codex 2026-01-18 10:15:52Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: 889de4
Wall time: 0.0516 seconds
Process exited with code 0
Original token count: 389
Output:
import type { EditorView } from '@codemirror/view'

import { HighlightStyle, syntaxHighlighting } from '@codemirror/language'
import { tags } from '@lezer/highlight'

import { useEditorConfig } from '../universal/use-editor-setting'
import { codemirrorReconfigureExtensionMap } from './extension'

export const monospaceFonts = `"OperatorMonoSSmLig Nerd Font","Cascadia Code PL","FantasqueSansMono Nerd Font","operator mono","Fira code Retina","Fira code","Consolas", Monaco, "Hannotate SC", monospace, -apple-system`

const markdownTags = [
  tags.heading1,
  tags.heading2,
  tags.heading3,
  tags.heading4,
  tags.heading5,
  tags.heading6,
  tags.strong,
  tags.emphasis,
  tags.deleted,
  tags.content,
  tags.url,
  tags.link,
]

export const useCodeMirrorConfigureFonts = (
  editorView: Ref<EditorView | undefined>,
) => {
  const { general } = useEditorConfig()

  watch(
    () => [general.setting.fontFamily, editorView.value],
    ([fontFamily]) => {
      if (!editorView.value) return
      const sansFonts = fontFamily || 'var(--sans-font)'

      const fontStyles = HighlightStyle.define([
        {
          tag: [tags.processingInstruction, tags.monospace],
          fontFamily: monospaceFonts,
        },
        { tag: markdownTags, fontFamily: sansFonts },
      ])

      editorView.value.dispatch({
        effects: [
          codemirrorReconfigureExtensionMap.fonts.reconfigure([
            syntaxHighlighting(fontStyles),
          ]),
        ],
      })
    },
    {
      immediate: true,
      flush: 'post',
    },
  )
}
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-18 10:18:25Z)**_

<think><details><summary>Thought Process</summary>
**Identifying block decoration error cause**

The error arises because the codeBlockWysiwygPlugin uses a ViewPlugin to provide block decorations, which CM6 forbids; block decorations must come from a StateField or extension like in the dividerWysiwyg plugin to avoid this issue.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-18 10:18:25Z)**_

<think><details><summary>Thought Process</summary>
**Diagnosing WYSIWYG initial load failure**

The block decoration error thrown by the codeBlock plugin during extension reconfigure likely aborts extension setup, preventing WYSIWYG inline and block decorations from rendering on first load. The fix involves replacing the codeBlock ViewPlugin with a StateField-based extension to provide block decorations without errors.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-18 10:18:25Z)**_

<think><details><summary>Thought Process</summary>
**Planning block decoration rebuild on effects**

Deciding to rebuild code block decorations on any transaction effects (to capture theme toggles and reconfigures) alongside doc and selection changes; this supports dynamic updates while fixing the block decoration error by migrating the code block plugin to a StateField-based extension.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-18 10:18:36Z)**_

<tool-use data-tool-type="write" data-tool-name="apply_patch"><details>
<summary>Tool use: **apply_patch**</summary>
**Update: `src/components/editor/codemirror/wysiwyg-codeblock.ts`**

```diff
@@
-import type { DecorationSet, EditorView } from '@codemirror/view'
-import { Decoration, WidgetType, ViewPlugin } from '@codemirror/view'
-import type { EditorState, Range } from '@codemirror/state'
+import type { DecorationSet } from '@codemirror/view'
+import { Decoration, EditorView, WidgetType } from '@codemirror/view'
+import type { EditorState, Range } from '@codemirror/state'
+import { StateField } from '@codemirror/state'
@@
-// Use ViewPlugin to react to selection changes
-const codeBlockWysiwygPlugin = ViewPlugin.fromClass(
-  class {
-    decorations: DecorationSet
-
-    constructor(view: EditorView) {
-      this.decorations = buildCodeBlockDecorations(view.state)
-    }
-
-    update(update: {
-      docChanged: boolean
-      selectionSet: boolean
-      state: EditorState
-    }) {
-      if (update.docChanged || update.selectionSet) {
-        this.decorations = buildCodeBlockDecorations(update.state)
-      }
-    }
-  },
-  {
-    decorations: (v) => v.decorations,
-  },
-)
-
-export const codeBlockWysiwygExtension = [codeBlockWysiwygPlugin]
+const codeBlockWysiwygField = StateField.define<DecorationSet>({
+  create(state) {
+    return buildCodeBlockDecorations(state)
+  },
+  update(value, tr) {
+    const selectionChanged = !tr.startState.selection.eq(tr.state.selection)
+    const effectsChanged = tr.effects.length > 0
+
+    if (!tr.docChanged && !selectionChanged && !effectsChanged) {
+      return value
+    }
+
+    return buildCodeBlockDecorations(tr.state)
+  },
+  provide: (field) => EditorView.decorations.from(field),
+})
+
+export const codeBlockWysiwygExtension = [codeBlockWysiwygField]
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-18 10:18:57Z)**_

<think><details><summary>Thought Process</summary>
**Verifying Transaction properties**

I confirmed `tr.effects` is always an array, so no default needed, but adding a length check avoids errors. Also checked `EditorView` use is only as a value, not a type. I'm clarifying that `Transaction` has both `startState` and `state` (new state), which is important for accessing selection in field updates.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-18 10:18:57Z)**_

<think><details><summary>Thought Process</summary>
**Confirming correct EditorState and EditorView usage**

I verified using `tr.state` in state field updates is valid for accessing the new state and its selection with the `eq` method. Also confirmed `EditorView` is only imported as a runtime value, never used as a type, so the import is appropriate. Next, I'll check for any lint or type errors by reviewing the file.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-18 10:18:57Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: f48c38
Wall time: 0.0510 seconds
Process exited with code 0
Original token count: 1726
Output:
import type { DecorationSet } from '@codemirror/view'
import { Decoration, EditorView, WidgetType } from '@codemirror/view'
import type { EditorState, Range } from '@codemirror/state'
import { StateField } from '@codemirror/state'
import { codeToHtml } from 'shiki'

// Widget for code block with shiki highlighting
class CodeBlockWidget extends WidgetType {
  private static highlightCache = new Map<string, string>()
  private static pendingHighlights = new Map<string, Promise<string>>()

  constructor(
    readonly code: string,
    readonly language: string,
    readonly isDark: boolean,
  ) {
    super()
  }

  toDOM(): HTMLElement {
    const wrapper = document.createElement('div')
    wrapper.className = 'cm-wysiwyg-codeblock'

    // Language label
    if (this.language) {
      const langLabel = document.createElement('div')
      langLabel.className = 'cm-wysiwyg-codeblock-lang'
      langLabel.textContent = this.language
      wrapper.appendChild(langLabel)
    }

    // Code container
    const codeContainer = document.createElement('div')
    codeContainer.className = 'cm-wysiwyg-codeblock-content'
    codeContainer.textContent = this.code
    wrapper.appendChild(codeContainer)

    // Try to get cached highlight
    const cacheKey = `${this.language}:${this.isDark}:${this.code}`
    const cached = CodeBlockWidget.highlightCache.get(cacheKey)
    if (cached) {
      codeContainer.innerHTML = cached
      return wrapper
    }

    // Check if highlight is already pending
    const pending = CodeBlockWidget.pendingHighlights.get(cacheKey)
    if (pending) {
      pending.then((html) => {
        if (codeContainer.isConnected) {
          codeContainer.innerHTML = html
        }
      })
      return wrapper
    }

    // Start async highlight
    const highlightPromise = this.highlight()
    CodeBlockWidget.pendingHighlights.set(cacheKey, highlightPromise)

    highlightPromise.then((html) => {
      CodeBlockWidget.highlightCache.set(cacheKey, html)
      CodeBlockWidget.pendingHighlights.delete(cacheKey)
      if (codeContainer.isConnected) {
        codeContainer.innerHTML = html
      }
    })

    return wrapper
  }

  private async highlight(): Promise<string> {
    try {
      // Map common language aliases
      const langMap: Record<string, string> = {
        js: 'javascript',
        ts: 'typescript',
        tsx: 'tsx',
        jsx: 'jsx',
        py: 'python',
        rb: 'ruby',
        sh: 'bash',
        shell: 'bash',
        yml: 'yaml',
        md: 'markdown',
      }

      const lang = langMap[this.language] || this.language || 'text'

      const html = await codeToHtml(this.code, {
        lang,
        theme: this.isDark ? 'github-dark' : 'github-light',
      })

      // Extract just the code content from shiki's output
      // shiki outputs: <pre class="..." style="..."><code>...</code></pre>
      const match = html.match(/<code[^>]*>([\s\S]*?)<\/code>/)
      return match ? match[1] : this.escapeHtml(this.code)
    } catch {
      // If language is not supported, return escaped plain text
      return this.escapeHtml(this.code)
    }
  }

  private escapeHtml(text: string): string {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/\n/g, '<br>')
  }

  eq(other: CodeBlockWidget): boolean {
    return (
      this.code === other.code &&
      this.language === other.language &&
      this.isDark === other.isDark
    )
  }

  ignoreEvent(): boolean {
    return false
  }
}

interface CodeBlock {
  startLine: number
  endLine: number
  language: string
  code: string
  startFrom: number
  endTo: number
}

// Find all code blocks in the document
const findCodeBlocks = (state: EditorState): CodeBlock[] => {
  const blocks: CodeBlock[] = []
  const codeBlockStartRegex = /^```(\w*)$/
  const codeBlockEndRegex = /^```$/

  let inCodeBlock = false
  let currentBlock: Partial<CodeBlock> & { codeLines?: string[] } = {}

  for (let lineNumber = 1; lineNumber <= state.doc.lines; lineNumber++) {
    const line = state.doc.line(lineNumber)

    if (!inCodeBlock) {
      const startMatch = codeBlockStartRegex.exec(line.text)
      if (startMatch) {
        inCodeBlock = true
        currentBlock = {
          startLine: lineNumber,
          language: startMatch[1] || '',
          startFrom: line.from,
          codeLines: [],
        }
      }
    } else {
      if (codeBlockEndRegex.test(line.text)) {
        blocks.push({
          startLine: currentBlock.startLine!,
          endLine: lineNumber,
          language: currentBlock.language!,
          code: currentBlock.codeLines!.join('\n'),
          startFrom: currentBlock.startFrom!,
          endTo: line.to,
        })
        inCodeBlock = false
        currentBlock = {}
      } else {
        currentBlock.codeLines!.push(line.text)
      }
    }
  }

  re
... (truncated)
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-18 10:20:03Z)**_

<think><details><summary>Thought Process</summary>
**Verifying CodeMirror StateField integration**

I'm confirming that using `EditorState.selection` with `eq` is correct and that `StateField` combined with `EditorView.decorations.from` plus `provide` aligns with existing patterns. The use of `document.documentElement` is consistent with prior client-side code. Next, I’ll check if the error about block decorations from plugins is resolved and ensure the new StateField extension is properly included in the reconfigure compartment for WYSIWYG.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-18 10:20:03Z)**_

<think><details><summary>Thought Process</summary>
**解释代码块 WYSIWYG 修复**

已把 code block WYSIWYG 的装饰从 ViewPlugin 移到 StateField，避免 CodeMirror 对 block decoration 的限制导致 reconfigure 抛错，从而影响首次渲染。

- 在 `src/components/editor/codemirror/wysiwyg-codeblock.ts` 用 `StateField` + `EditorView.decorations.from` 提供 block replace 装饰，并在文档、选区和副作用变更时重建  
- 解决了因插件返回 block decorations 导致的 `Block decorations may not be specified via plugins` 错误，保证 WYSIWYG 扩展能正常应用，首次加载即可正确渲染 inline code、图片和代码块  

下一步建议：  
1) 重新加载页面并确认编辑器的 WYSIWYG 正常显示，无报错  
2) 可尝试切换 WYSIWYG 模式，确保切换时代码块高亮和渲染正常  
3) 如需支持块级图片（整行仅含图片时块级显示），可再扩展图片插件进行检测和调整
</details></think>

_**Agent (gpt-5.2-codex 2026-01-18 10:20:05Z)**_

把 code block 的 WYSIWYG 装饰改为 StateField 提供，避免 CodeMirror 对 block decoration 的限制在 reconfigure 时抛错，从而让首次加载就能正常渲染 inline/image/code block 的 WYSIWYG。  
- 在 `src/components/editor/codemirror/wysiwyg-codeblock.ts` 用 `StateField` + `EditorView.decorations.from` 取代 `ViewPlugin`，并在 doc/selection/effects 变化时重建装饰，保留原有 block replace 与主题判断逻辑，避免 `Block decorations may not be specified via plugins` 让扩展整体失效

下一步建议：
1) 刷新后确认控制台不再报错，首次加载内容能直接呈现 WYSIWYG  
2) 如果你希望“独占一行的图片”显示为真正块级样式，我可以再加单行图片识别与 block widget/样式处理

---

_**User (2026-01-18 10:29:08Z)**_

现在还有一点小问题，就是在方向键上下移动的时候，无法进入到 code block 块中去进行代码编辑. 会直接跳过这一个块，进入到上一行中. 同样的，现在也无法通过鼠标点击的方式，进入到编辑这个代码块中

---

_**Agent (gpt-5.2-codex 2026-01-18 10:32:13Z)**_

<think><details><summary>Thought Process</summary>
**Planning selection fix for replaced code block**

The current replaced code block uses Decoration.replace with block true, which removes text and blocks cursor entry. The plan is to implement a widget that, on click or arrow key, switches to editing mode and moves the cursor into the block since selection can't be inside replaced content.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-18 10:32:13Z)**_

<think><details><summary>Thought Process</summary>
**Designing arrow key and click handlers to enter replaced code blocks**

Selection can't naturally enter replaced code blocks since decorations hide the text, so the plan is to add click handlers on the block widget to programmatically set the cursor inside the code block (at first code line). For arrow keys, I'll add keymap handlers that detect when arrow up/down moves toward a collapsed code block and shift selection inside it to trigger editing mode and show raw markdown.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-18 10:32:13Z)**_

<think><details><summary>Thought Process</summary>
**Finalizing arrow key and click behavior with computed entry positions**

The plan is to detect adjacent collapsed code blocks on arrow up/down and, on those keys, programmatically move the cursor inside the block at computed positions (start of code lines for down, end for up). The code block widget gets updated to receive this entry position and adds a mousedown handler that sets selection inside the block to trigger editing mode. This coordinated approach enables entering replaced code blocks via keyboard or mouse.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-18 10:32:13Z)**_

<think><details><summary>Thought Process</summary>
**Adding keymap and widget updates with position-aware cursor entry**

The plan is to extend the code block widget to include an entry position and add click handling to move the cursor inside on mouse down. I'll also add helper functions to compute cursor entry/exit positions, include these in widget equality for proper DOM updates, and add a keymap intercepting arrow keys to programmatically move selection inside collapsed code blocks. These will be integrated into the WYSIWYG code block extension.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-18 10:32:35Z)**_

<tool-use data-tool-type="write" data-tool-name="apply_patch"><details>
<summary>Tool use: **apply_patch**</summary>
**Update: `src/components/editor/codemirror/wysiwyg-codeblock.ts`**

```diff
@@
-import type { DecorationSet } from '@codemirror/view'
-import { Decoration, EditorView, WidgetType } from '@codemirror/view'
+import type { DecorationSet } from '@codemirror/view'
+import { Decoration, EditorView, WidgetType, keymap } from '@codemirror/view'
@@
 class CodeBlockWidget extends WidgetType {
@@
   constructor(
     readonly code: string,
     readonly language: string,
     readonly isDark: boolean,
+    readonly enterPos: number,
   ) {
     super()
   }
 
-  toDOM(): HTMLElement {
+  toDOM(view: EditorView): HTMLElement {
     const wrapper = document.createElement('div')
     wrapper.className = 'cm-wysiwyg-codeblock'
 
     // Language label
@@
     codeContainer.textContent = this.code
     wrapper.appendChild(codeContainer)
 
+    wrapper.addEventListener('mousedown', (event) => {
+      if (event.button !== 0) return
+      event.preventDefault()
+      view.dispatch({
+        selection: { anchor: this.enterPos },
+        scrollIntoView: true,
+      })
+      view.focus()
+    })
+
     // Try to get cached highlight
@@
   eq(other: CodeBlockWidget): boolean {
     return (
       this.code === other.code &&
       this.language === other.language &&
-      this.isDark === other.isDark
+      this.isDark === other.isDark &&
+      this.enterPos === other.enterPos
     )
   }
@@
 const isDarkMode = (): boolean => {
   return document.documentElement.classList.contains('dark')
 }
 
+const getCodeBlockEntryPos = (
+  state: EditorState,
+  block: CodeBlock,
+): number => {
+  const lineNumber = Math.min(block.startLine + 1, block.endLine)
+  return state.doc.line(lineNumber).from
+}
+
+const getCodeBlockExitPos = (
+  state: EditorState,
+  block: CodeBlock,
+): number => {
+  const lineNumber = Math.max(block.endLine - 1, block.startLine + 1)
+  return state.doc.line(lineNumber).from
+}
+
+const getBlockContainingSelection = (
+  state: EditorState,
+  blocks: CodeBlock[],
+): CodeBlock | undefined => {
+  return blocks.find((block) => isCursorInCodeBlock(state, block))
+}
+
 const buildCodeBlockDecorations = (state: EditorState): DecorationSet => {
   const decorations: Range<Decoration>[] = []
   const blocks = findCodeBlocks(state)
   const dark = isDarkMode()
@@
       // When cursor is outside, replace entire block with highlighted widget
       decorations.push(
         Decoration.replace({
-          widget: new CodeBlockWidget(block.code, block.language, dark),
+          widget: new CodeBlockWidget(
+            block.code,
+            block.language,
+            dark,
+            getCodeBlockEntryPos(state, block),
+          ),
           block: true,
         }).range(block.startFrom, block.endTo),
       )
     }
   }
@@
   provide: (field) => EditorView.decorations.from(field),
 })
 
-export const codeBlockWysiwygExtension = [codeBlockWysiwygField]
+const codeBlockWysiwygKeymap = keymap.of([
+  {
+    key: 'ArrowDown',
+    run(view) {
+      const { state } = view
+      if (!state.selection.main.empty) return false
+
+      const blocks = findCodeBlocks(state)
+      if (getBlockContainingSelection(state, blocks)) return false
+
+      const currentLine = state.doc.lineAt(state.selection.main.head)
+      const nextLineNumber = currentLine.number + 1
+      if (nextLineNumber > state.doc.lines) return false
+
+      const block = blocks.find((item) => item.startLine === nextLineNumber)
+      if (!block) return false
+
+      view.dispatch({
+        selection: { anchor: getCodeBlockEntryPos(state, block) },
+        scrollIntoView: true,
+      })
+      return true
+    },
+  },
+  {
+    key: 'ArrowUp',
+    run(view) {
+      const { state } = view
+      if (!state.selection.main.empty) return false
+
+      const blocks = findCodeBlocks(state)
+      if (getBlockContainingSelection(state, blocks)) return false
+
+      const currentLine = state.doc.lineAt(state.selection.main.head)
+      const prevLineNumber = currentLine.number - 1
+      if (prevLineNumber < 1) return false
+
+      const block = blocks.find((item) => item.endLine === prevLineNumber)
+      if (!block) return false
+
+      view.dispatch({
+        selection: { anchor: getCodeBlockExitPos(state, block) },
+        scrollIntoView: true,
+      })
+      return true
+    },
+  },
+])
+
+export const codeBlockWysiwygExtension = [
+  codeBlockWysiwygField,
+  codeBlockWysiwygKeymap,
+]
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-18 10:33:05Z)**_

<think><details><summary>Thought Process</summary>
**Validating EditorView usage and keymap imports**

Confirmed EditorView is used in widget rendering and field decoration without import issues, and keymap is correctly imported for the extension. The arrow-up position logic handles edge cases of single-line blocks acceptably.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-18 10:33:05Z)**_

<think><details><summary>Thought Process</summary>
**Confirming arrow key and click entry into code blocks**

The code now supports entering collapsed code blocks via ArrowUp/Down and clicking, implemented with position helpers and key handling in `src/components/editor/codemirror/wysiwyg-codeblock.ts`. Next, testing navigation and considering optional enhancements for mouse entry or additional keys would be helpful.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-18 10:33:08Z)**_

让 code block 在 WYSIWYG 模式下能被进入编辑：点击预览块会把光标送到块内，方向键上下遇到折叠的 code block 会自动进入块内，从而切换到可编辑的 markdown 视图。  
- 在 `src/components/editor/codemirror/wysiwyg-codeblock.ts` 给 code block widget 加了 `mousedown` 定位光标的逻辑，并新增 `ArrowUp/ArrowDown` 的 keymap，在相邻行遇到折叠 code block 时跳入块内；同时为点击定位缓存了进入位置，避免位置变化时复用旧 widget

下一步建议：
1) 验证上下方向键与鼠标点击能进入 code block 并正常编辑  
2) 如果希望进入位置更靠近“代码内容末尾/中间”，我可以按你偏好调整进入位置规则

---

_**User (2026-01-18 10:37:19Z)**_

现在通过方向键还是会直接跳过 code block

---

_**Agent (gpt-5.2-codex 2026-01-18 10:38:19Z)**_

<think><details><summary>Thought Process</summary>
**Debugging keymap precedence**

I'm analyzing that the keymap may be inactive due to its lower precedence within the compartment or conflict with default handlers; wrapping the keymap in a highest-precedence wrapper from the state package could ensure it overrides built-in keymaps.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-18 10:38:19Z)**_

<think><details><summary>Thought Process</summary>
**Confirming keymap precedence and implementing Prec.highest**

The keymap likely doesn't trigger because default keymaps with arrow keys have higher precedence due to extension order, so wrapping our keymap in Prec.highest will ensure it runs first and can intercept arrow keys as intended. I'll proceed to import Prec and update the keymap accordingly.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-18 10:38:35Z)**_

<tool-use data-tool-type="write" data-tool-name="apply_patch"><details>
<summary>Tool use: **apply_patch**</summary>
**Update: `src/components/editor/codemirror/wysiwyg-codeblock.ts`**

```diff
@@
-import type { EditorState, Range } from '@codemirror/state'
-import { StateField } from '@codemirror/state'
+import type { EditorState, Range } from '@codemirror/state'
+import { Prec, StateField } from '@codemirror/state'
@@
-const codeBlockWysiwygKeymap = keymap.of([
-  {
-    key: 'ArrowDown',
-    run(view) {
-      const { state } = view
-      if (!state.selection.main.empty) return false
-
-      const blocks = findCodeBlocks(state)
-      if (getBlockContainingSelection(state, blocks)) return false
-
-      const currentLine = state.doc.lineAt(state.selection.main.head)
-      const nextLineNumber = currentLine.number + 1
-      if (nextLineNumber > state.doc.lines) return false
-
-      const block = blocks.find((item) => item.startLine === nextLineNumber)
-      if (!block) return false
-
-      view.dispatch({
-        selection: { anchor: getCodeBlockEntryPos(state, block) },
-        scrollIntoView: true,
-      })
-      return true
-    },
-  },
-  {
-    key: 'ArrowUp',
-    run(view) {
-      const { state } = view
-      if (!state.selection.main.empty) return false
-
-      const blocks = findCodeBlocks(state)
-      if (getBlockContainingSelection(state, blocks)) return false
-
-      const currentLine = state.doc.lineAt(state.selection.main.head)
-      const prevLineNumber = currentLine.number - 1
-      if (prevLineNumber < 1) return false
-
-      const block = blocks.find((item) => item.endLine === prevLineNumber)
-      if (!block) return false
-
-      view.dispatch({
-        selection: { anchor: getCodeBlockExitPos(state, block) },
-        scrollIntoView: true,
-      })
-      return true
-    },
-  },
-])
+const codeBlockWysiwygKeymap = Prec.highest(
+  keymap.of([
+    {
+      key: 'ArrowDown',
+      run(view) {
+        const { state } = view
+        if (!state.selection.main.empty) return false
+
+        const blocks = findCodeBlocks(state)
+        if (getBlockContainingSelection(state, blocks)) return false
+
+        const currentLine = state.doc.lineAt(state.selection.main.head)
+        const nextLineNumber = currentLine.number + 1
+        if (nextLineNumber > state.doc.lines) return false
+
+        const block = blocks.find((item) => item.startLine === nextLineNumber)
+        if (!block) return false
+
+        view.dispatch({
+          selection: { anchor: getCodeBlockEntryPos(state, block) },
+          scrollIntoView: true,
+        })
+        return true
+      },
+    },
+    {
+      key: 'ArrowUp',
+      run(view) {
+        const { state } = view
+        if (!state.selection.main.empty) return false
+
+        const blocks = findCodeBlocks(state)
+        if (getBlockContainingSelection(state, blocks)) return false
+
+        const currentLine = state.doc.lineAt(state.selection.main.head)
+        const prevLineNumber = currentLine.number - 1
+        if (prevLineNumber < 1) return false
+
+        const block = blocks.find((item) => item.endLine === prevLineNumber)
+        if (!block) return false
+
+        view.dispatch({
+          selection: { anchor: getCodeBlockExitPos(state, block) },
+          scrollIntoView: true,
+        })
+        return true
+      },
+    },
+  ]),
+)
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-18 10:38:40Z)**_

把方向键 keymap 提升到最高优先级，避免被默认的 `ArrowUp/ArrowDown` 行移动先吞掉。  
- 更新在 `src/components/editor/codemirror/wysiwyg-codeblock.ts`，用 `Prec.highest` 包裹 keymap

你试一下这版还有没有“继续跳过 code block”。如果还会跳，请告诉我：  
1) 光标在哪一行时按方向键（紧邻 code block 的上一行/下一行，还是隔着空行）  
2) code block 里是否为空、是否有语言标记 ```js
