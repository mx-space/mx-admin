<!-- Generated by SpecStory, Markdown v2.1.0 -->

# 2026-01-20 08:43:54Z

<!-- Codex CLI Session 019bda92-7b38-73b3-86b6-0b7ad8eb911a (2026-01-20 08:43:54Z) -->

_**User (2026-01-20 08:43:54Z)**_

src/components/editor/codemirror/wysiwyg-codeblock.ts 现在我们在方向键导航，在块与块之间移动时，会跳过 Block Code 进入到其他块。你看一下为什么？

---

_**Agent (gpt-5.2-codex 2026-01-20 08:43:57Z)**_

<think><details><summary>Thought Process</summary>
**Opening file for inspection**
</details></think>

_**Agent (gpt-5.2-codex 2026-01-20 08:43:58Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: dcc115
Wall time: 0.0518 seconds
Process exited with code 0
Original token count: 96
Output:
biome.json
CHANGELOG.md
CLAUDE.md
cliff.toml
create-tags.sh
dist
docs
favicon.png
ICON_MIGRATION.md
index.html
LICENSE
migrate-restmanager.sh
MIGRATION_GUIDE.md
MIGRATION_STATUS.md
netlify.toml
node_modules
package.json
pnpm-lock.yaml
polyfills
postcss.config.js
readme.md
REFACTOR_PLAN.md
release.sh
renovate.json
scripts
src
stats.html
tsconfig.json
uno.config.ts
vite.config.mts
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-20 08:43:59Z)**_

<think><details><summary>Thought Process</summary>
**Preparing to read file contents**
</details></think>

_**Agent (gpt-5.2-codex 2026-01-20 08:44:00Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: 8bd7c8
Wall time: 0.0517 seconds
Process exited with code 0
Original token count: 1535
Output:
import { html, LitElement, nothing } from 'lit'
import type { Range } from '@codemirror/state'
import type { DecorationSet } from '@codemirror/view'

import { history, historyKeymap, indentWithTab } from '@codemirror/commands'
import { Compartment, EditorState, Prec, StateField } from '@codemirror/state'
import { LanguageDescription } from '@codemirror/language'
import { languages } from '@codemirror/language-data'
import { oneDark } from '@codemirror/theme-one-dark'
import { githubLight } from '@ddietr/codemirror-themes/theme/github-light'
import { Decoration, EditorView, keymap, WidgetType } from '@codemirror/view'

const codeBlockStartRegex = /^```(?!`)(.*)$/
const codeBlockEndRegex = /^```\s*$/
const codeBlockLanguageRegex = /^[\w#+.-]+$/
const codeBlockTagName = 'cm-wysiwyg-codeblock'

const languageAliasMap: Record<string, string> = {
  js: 'javascript',
  ts: 'typescript',
  tsx: 'tsx',
  jsx: 'jsx',
  py: 'python',
  rb: 'ruby',
  sh: 'bash',
  shell: 'bash',
  yml: 'yaml',
  md: 'markdown',
}

const parseCodeBlockLanguage = (info: string): string => {
  if (!info) return ''
  const [firstToken] = info.trim().split(/\s+/)
  if (!firstToken) return ''
  return codeBlockLanguageRegex.test(firstToken) ? firstToken : ''
}

const findLanguageDescription = (language: string): LanguageDescription | null => {
  if (!language) return null
  const normalized = languageAliasMap[language] || language
  return LanguageDescription.matchLanguageName(languages, normalized, true)
}

class CodeBlockElement extends LitElement {
  static properties = {
    code: { type: String },
    language: { type: String },
    isDark: { type: Boolean },
  }

  declare code: string
  declare language: string
  declare isDark: boolean

  enterPos = 0
  contentFrom = 0
  contentTo = 0
  outerView?: EditorView

  private innerView?: EditorView
  private syncingFromOuter = false
  private languageCompartment = new Compartment()
  private themeCompartment = new Compartment()
  private languageLoadId = 0

  constructor() {
    super()
    this.code = ''
    this.language = ''
    this.isDark = false
  }

  createRenderRoot(): HTMLElement {
    return this
  }

  connectedCallback(): void {
    super.connectedCallback()
    this.classList.add('cm-wysiwyg-codeblock')
  }

  render(): ReturnType<typeof html> {
    return html`
      ${this.language
        ? html`<div class="cm-wysiwyg-codeblock-lang">${this.language}</div>`
        : nothing}
      <div class="cm-wysiwyg-codeblock-area">
        <div class="cm-wysiwyg-codeblock-editor"></div>
      </div>
    `
  }

  firstUpdated(): void {
    const editorHost = this.querySelector(
      '.cm-wysiwyg-codeblock-editor',
    ) as HTMLElement | null
    if (editorHost) {
      this.createInnerEditor(editorHost)
    }
    this.addEventListener('mousedown', this.handleMouseDown)
  }

  updated(changed: Map<string, unknown>): void {
    if (!this.innerView) {
      const editorHost = this.querySelector(
        '.cm-wysiwyg-codeblock-editor',
      ) as HTMLElement | null
      if (editorHost) {
        this.createInnerEditor(editorHost)
      }
    }

    if (changed.has('code')) {
      this.syncInnerDoc()
    }

    if (changed.has('language')) {
      this.applyLanguage()
    }

    if (changed.has('isDark')) {
      this.applyTheme()
    }
  }

  disconnectedCallback(): void {
    this.removeEventListener('mousedown', this.handleMouseDown)
    this.innerView?.dom.removeEventListener('focusin', this.handleFocus)
    this.innerView?.destroy()
    this.innerView = undefined
    super.disconnectedCallback()
  }

  focusEditor(position: 'start' | 'end' = 'start'): void {
    const focus = () => {
      if (!this.innerView) return
      const docLength = this.innerView.state.doc.length
      const anchor = position === 'end' ? docLength : 0
      this.innerView.dispatch({ selection: { anchor } })
      this.innerView.focus()
    }

    if (this.innerView) {
      focus()
      return
    }

    void this.updateComplete.then(focus)
  }

  private createInnerEditor(host: HTMLElement): void {
    if (this.innerView) return

    const state = EditorState.create({
      doc: this.code,
      extensions: [
        history(),
        keymap.of([...historyKeymap, indentWithTab]),
        EditorState.tabSize.of(2),
        this.languageCompartment.of([]),
        this.themeCompartment.of(this.isDark ? oneDark : githubLight),
        EditorView.contentAttributes.of({
          spellcheck: 'false',
          autocapitalize: 'off',
          autocomplete: 'off',
          autocorrect: 'off',
        }),
        EditorView.updateListener.of((update) => {
          if (!update.docChanged || this.syncingFromOuter) return
          this.syncOuterDoc(update.state.doc.toString())
        }),
      ],
    })

    this.innerView = new EditorView({ state, parent: host })
    this.innerView.dom.addEventListener('f
... (truncated)
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-20 08:44:03Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: 7d05d3
Wall time: 0.0514 seconds
Process exited with code 0
Original token count: 2107
Output:
  private applyTheme(): void {
    if (!this.innerView) return
    const theme = this.isDark ? oneDark : githubLight
    this.innerView.dispatch({
      effects: this.themeCompartment.reconfigure(theme),
    })
  }

  private applyLanguage(): void {
    if (!this.innerView) return
    const description = findLanguageDescription(this.language)
    const requestId = ++this.languageLoadId

    if (!description) {
      this.innerView.dispatch({
        effects: this.languageCompartment.reconfigure([]),
      })
      return
    }

    description
      .load()
      .then((support) => {
        if (!this.innerView || requestId !== this.languageLoadId) return
        this.innerView.dispatch({
          effects: this.languageCompartment.reconfigure(support),
        })
      })
      .catch(() => {
        if (!this.innerView || requestId !== this.languageLoadId) return
        this.innerView.dispatch({
          effects: this.languageCompartment.reconfigure([]),
        })
      })
  }
}

if (!customElements.get(codeBlockTagName)) {
  customElements.define(codeBlockTagName, CodeBlockElement)
}

// Widget for code block with codemirror highlighting
class CodeBlockWidget extends WidgetType {
  constructor(
    readonly code: string,
    readonly language: string,
    readonly isDark: boolean,
    readonly enterPos: number,
    readonly contentFrom: number,
    readonly contentTo: number,
  ) {
    super()
  }

  toDOM(view: EditorView): HTMLElement {
    const element = document.createElement(codeBlockTagName) as CodeBlockElement
    element.code = this.code
    element.language = this.language
    element.isDark = this.isDark
    element.enterPos = this.enterPos
    element.contentFrom = this.contentFrom
    element.contentTo = this.contentTo
    element.outerView = view
    element.dataset.enterPos = String(this.enterPos)
    return element
  }

  updateDOM(dom: HTMLElement, view: EditorView): boolean {
    if (!(dom instanceof CodeBlockElement)) return false
    dom.code = this.code
    dom.language = this.language
    dom.isDark = this.isDark
    dom.enterPos = this.enterPos
    dom.contentFrom = this.contentFrom
    dom.contentTo = this.contentTo
    dom.outerView = view
    dom.dataset.enterPos = String(this.enterPos)
    return true
  }

  eq(other: CodeBlockWidget): boolean {
    return (
      this.code === other.code &&
      this.language === other.language &&
      this.isDark === other.isDark &&
      this.enterPos === other.enterPos &&
      this.contentFrom === other.contentFrom &&
      this.contentTo === other.contentTo
    )
  }

  ignoreEvent(_event: Event): boolean {
    return true
  }
}

interface CodeBlock {
  startLine: number
  endLine: number
  language: string
  code: string
  startFrom: number
  endTo: number
  contentFrom: number
  contentTo: number
}

// Find all code blocks in the document
const findCodeBlocks = (state: EditorState): CodeBlock[] => {
  const blocks: CodeBlock[] = []

  let inCodeBlock = false
  let currentBlock: Partial<CodeBlock> & { codeLines?: string[] } = {}

  for (let lineNumber = 1; lineNumber <= state.doc.lines; lineNumber++) {
    const line = state.doc.line(lineNumber)

    if (!inCodeBlock) {
      const startMatch = codeBlockStartRegex.exec(line.text)
      if (startMatch) {
        inCodeBlock = true
        const info = startMatch[1].trim()
        currentBlock = {
          startLine: lineNumber,
          language: parseCodeBlockLanguage(info),
          startFrom: line.from,
          codeLines: [],
        }
      }
    } else {
      if (codeBlockEndRegex.test(line.text)) {
        const contentStartLine = currentBlock.startLine! + 1
        const contentEndLine = lineNumber - 1
        const hasContent = contentStartLine <= contentEndLine
        const contentFrom = hasContent
          ? state.doc.line(contentStartLine).from
          : line.from
        const contentTo = hasContent
          ? state.doc.line(contentEndLine).to
          : line.from
        blocks.push({
          startLine: currentBlock.startLine!,
          endLine: lineNumber,
          language: currentBlock.language!,
          code: currentBlock.codeLines!.join('\n'),
          startFrom: currentBlock.startFrom!,
          endTo: line.to,
          contentFrom,
          contentTo,
        })
        inCodeBlock = false
        currentBlock = {}
      } else {
        currentBlock.codeLines!.push(line.text)
      }
    }
  }

  return blocks
}

// Check if cursor is within a code block
const isCursorInCodeBlock = (state: EditorState, block: CodeBlock): boolean => {
  const { from, to } = state.selection.main
  return from <= block.endTo && to >= block.startFrom
}

// Detect dark mode
const isDarkMode = (): boolean => {
  return document.documentElement.classList.contains('dark')
}

const getCodeBlockEntryPos = (state: EditorState, block: CodeBlock): number => {
  const 
... (truncated)
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-20 08:44:05Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: b590a9
Wall time: 0.0515 seconds
Process exited with code 0
Original token count: 228
Output:
        if (!state.selection.main.empty) return false

        const blocks = findCodeBlocks(state)
        if (getBlockContainingSelection(state, blocks)) return false

        const currentLine = state.doc.lineAt(state.selection.main.head)
        const prevLineNumber = currentLine.number - 1
        if (prevLineNumber < 1) return false

        const block = blocks.find((item) => item.endLine === prevLineNumber)
        if (!block) return false

        view.dispatch({
          selection: { anchor: getCodeBlockExitPos(state, block) },
          scrollIntoView: true,
        })
        focusCodeBlockEditor(view, getCodeBlockEntryPos(state, block), 'end')
        return true
      },
    },
  ]),
)

export const codeBlockWysiwygExtension = [
  codeBlockWysiwygField,
  codeBlockWysiwygKeymap,
]

declare global {
  interface HTMLElementTagNameMap {
    'cm-wysiwyg-codeblock': CodeBlockElement
  }
}
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-20 08:44:59Z)**_

<think><details><summary>Thought Process</summary>
**Analyzing arrow key navigation skipping code blocks**

I'm inspecting the keymap logic that checks for ArrowDown only when the next line matches the code block start (```), but since code blocks are replaced by widgets in the editor, the expected ``` line may not be visible or correctly detected, possibly causing arrow navigation to skip these blocks.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-20 08:44:59Z)**_

<think><details><summary>Thought Process</summary>
**Diagnosing atomic widget causing block navigation skip**

The replaced code block range uses a block widget marked atomic, causing the cursor to leap over it during arrow key navigation; since the keymap only triggers when the next line exactly matches the code block start, blocks separated by blank lines or atomic replacement cause navigation to skip the code block instead of entering it.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-20 08:44:59Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: 071845
Wall time: 0.0511 seconds
Process exited with code 0
Original token count: 176
Output:
src/components/editor/codemirror/wysiwyg-codeblock.ts:469:const codeBlockWysiwygField = StateField.define<DecorationSet>({
src/components/editor/codemirror/wysiwyg-codeblock.ts:486:const codeBlockWysiwygKeymap = Prec.highest(
src/components/editor/codemirror/wysiwyg-codeblock.ts:543:export const codeBlockWysiwygExtension = [
src/components/editor/codemirror/wysiwyg-codeblock.ts:544:  codeBlockWysiwygField,
src/components/editor/codemirror/wysiwyg-codeblock.ts:545:  codeBlockWysiwygKeymap,
src/components/editor/codemirror/codemirror.tsx:23:import { codeBlockWysiwygExtension } from './wysiwyg-codeblock'
src/components/editor/codemirror/codemirror.tsx:83:              ...codeBlockWysiwygExtension,
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-20 08:45:02Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: cdc114
Wall time: 0.0525 seconds
Process exited with code 0
Original token count: 1281
Output:
/* eslint-disable vue/no-setup-props-destructure */
import { defineComponent } from 'vue'
import type { EditorState } from '@codemirror/state'
import type { PropType } from 'vue'

import { useSaveConfirm } from '~/hooks/use-save-confirm'

import { FloatingToolbar } from '../toolbar/floating-toolbar'
import { useSelectionPosition } from '../toolbar/use-selection-position'
import styles from '../universal/editor.module.css'
import { editorBaseProps } from '../universal/props'

import 'katex/dist/katex.min.css'
import './codemirror.css'

import {
  codemirrorReconfigureExtensionMap,
  wysiwygModeExtension,
} from './extension'
import { ImageEditPopover } from './ImageEditPopover'
import { useCodeMirror } from './use-codemirror'
import { blockquoteWysiwygExtension } from './wysiwyg-blockquote'
import { codeBlockWysiwygExtension } from './wysiwyg-codeblock'
import { dividerWysiwygExtension } from './wysiwyg-divider'
import { emptyLineWysiwygExtension } from './wysiwyg-empty-line'
import { headingWysiwygExtension } from './wysiwyg-heading'
import { inlineWysiwygExtension } from './wysiwyg-inline'
import { listWysiwygExtension } from './wysiwyg-list'
import { mathWysiwygExtension } from './wysiwyg-math'

export const CodemirrorEditor = defineComponent({
  name: 'CodemirrorEditor',
  props: {
    ...editorBaseProps,
    onStateChange: {
      type: Function as PropType<(state: EditorState) => void>,
      required: false,
    },
    onArrowUpAtFirstLine: {
      type: Function as PropType<() => void>,
      required: false,
    },
    className: {
      type: String,
    },
  },
  setup(props, { expose }) {
    const [refContainer, editorView] = useCodeMirror({
      initialDoc: props.text,
      onChange: (state) => {
        props.onChange(state.doc.toString())
        props.onStateChange?.(state)
      },
      onArrowUpAtFirstLine: props.onArrowUpAtFirstLine,
    })

    watch(
      () => props.text,
      (n) => {
        const editor = editorView.value

        if (editor && n != editor.state.doc.toString()) {
          editor.dispatch({
            changes: { from: 0, to: editor.state.doc.length, insert: n },
          })
        }
      },
    )

    watch(
      () => [props.renderMode, editorView.value],
      ([renderMode]) => {
        const view = editorView.value
        if (!view) return

        const hadFocus = view.hasFocus
        const isWysiwyg = (renderMode ?? 'plain') === 'wysiwyg'
        const extensions = isWysiwyg
          ? [
              ...dividerWysiwygExtension,
              ...headingWysiwygExtension,
              ...inlineWysiwygExtension,
              ...codeBlockWysiwygExtension,
              ...listWysiwygExtension,
              ...blockquoteWysiwygExtension,
              ...mathWysiwygExtension,
              ...emptyLineWysiwygExtension,
            ]
          : []

        view.dispatch({
          effects: [
            codemirrorReconfigureExtensionMap.wysiwyg.reconfigure(extensions),
            codemirrorReconfigureExtensionMap.wysiwygMode.reconfigure(
              isWysiwyg ? [wysiwygModeExtension] : [],
            ),
          ],
        })

        if (hadFocus) {
          requestAnimationFrame(() => view.focus())
        }
      },
      {
        immediate: true,
        flush: 'post',
      },
    )

    expose({
      setValue: (value: string) => {
        const editor = editorView.value
        if (editor) {
          editor.dispatch({
            changes: { from: 0, to: editor.state.doc.length, insert: value },
          })
        }
      },
      focus: () => {
        editorView.value?.focus()
      },
    })

    const memoedText = props.text

    useSaveConfirm(
      props.unSaveConfirm,
      () => memoedText === editorView.value?.state.doc.toString(),
    )

    // 浮动工具栏选区位置追踪
    const { position, hasSelection } = useSelectionPosition(editorView)

    // 点击空白区域聚焦编辑器并将光标移到末尾 (WYSIWYG 模式)
    const handleContainerPointerDown = (e: PointerEvent) => {
      const view = editorView.value
      if (!view) return

      const isWysiwyg = (props.renderMode ?? 'plain') === 'wysiwyg'
      if (!isWysiwyg) return

      // 检查点击目标是否在 cm-content 内部
      const target = e.target as HTMLElement
      if (target.closest('.cm-content')) return

      // 点击的是空白区域，聚焦编辑器并将光标移到文档末尾
      e.preventDefault()
      view.focus()
      view.dispatch({
        selection: { anchor: view.state.doc.length },
      })
    }

    return () => (
      <div
        class="relative flex h-full flex-col"
        onPointerdown={handleContainerPointerDown}
      >
        <div
          class={[styles.editor, props.className, 'flex-1 overflow-auto']}
          ref={refContainer}
        />
        {/* 浮动工具栏 */}
        <FloatingToolba
... (truncated)
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-20 08:45:06Z)**_

<think><details><summary>Thought Process</summary>
**Searching for navigation logic**
</details></think>

_**Agent (gpt-5.2-codex 2026-01-20 08:45:07Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: 783e4d
Wall time: 0.0516 seconds
Process exited with code 0
Original token count: 273
Output:
src/components/editor/codemirror/wysiwyg-codeblock.ts:489:      key: 'ArrowDown',
src/components/editor/codemirror/wysiwyg-codeblock.ts:517:      key: 'ArrowUp',
src/components/editor/codemirror/use-codemirror.ts:32:  onArrowUpAtFirstLine?: () => void
src/components/editor/codemirror/use-codemirror.ts:41:  const { onChange, onArrowUpAtFirstLine } = props
src/components/editor/codemirror/use-codemirror.ts:134:            key: 'ArrowUp',
src/components/editor/codemirror/use-codemirror.ts:139:                onArrowUpAtFirstLine
src/components/editor/codemirror/use-codemirror.ts:147:                  onArrowUpAtFirstLine()
src/components/editor/codemirror/use-codemirror.ts:151:              return false // Use default ArrowUp behavior
src/components/editor/codemirror/wysiwyg-empty-line.ts:109:      key: 'ArrowUp',
src/components/editor/codemirror/wysiwyg-empty-line.ts:113:      key: 'ArrowDown',
src/components/editor/codemirror/codemirror.tsx:39:    onArrowUpAtFirstLine: {
src/components/editor/codemirror/codemirror.tsx:54:      onArrowUpAtFirstLine: props.onArrowUpAtFirstLine,
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-20 08:45:09Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: 24f5bf
Wall time: 0.0515 seconds
Process exited with code 0
Original token count: 1443
Output:
import { onMounted, ref } from 'vue'
import type { Ref } from 'vue'

import {
  defaultKeymap,
  history,
  historyKeymap,
  indentWithTab,
} from '@codemirror/commands'
import { markdownKeymap } from '@codemirror/lang-markdown'
import { bracketMatching, indentOnInput } from '@codemirror/language'
import { search, searchKeymap } from '@codemirror/search'
import { EditorState } from '@codemirror/state'
import {
  EditorView,
  highlightActiveLine,
  highlightActiveLineGutter,
  keymap,
  lineNumbers,
} from '@codemirror/view'

import { createToolbarKeymapExtension } from '../toolbar'
import { useEditorConfig } from '../universal/use-editor-setting'
import { codemirrorReconfigureExtension } from './extension'
import { syntaxTheme } from './syntax-highlight'
import { useCodeMirrorConfigureFonts } from './use-auto-fonts'
import { useCodeMirrorAutoToggleTheme } from './use-auto-theme'

interface Props {
  initialDoc: string
  onChange?: (state: EditorState) => void
  onArrowUpAtFirstLine?: () => void
}

export const useCodeMirror = <T extends Element>(
  props: Props,
): [Ref<T | undefined>, Ref<EditorView | undefined>] => {
  const refContainer = ref<T>()
  const editorView = ref<EditorView>()
  const { general } = useEditorConfig()
  const { onChange, onArrowUpAtFirstLine } = props

  const format = () => {
    const ev = editorView.value
    const autocorrect = general.setting.autocorrect

    if (autocorrect && ev) {
      import('@huacnlee/autocorrect')
        .then(({ formatFor }) => {
          const { state, dispatch } = ev
          const currentLine = state.doc.lineAt(state.selection.main.head)
          if (currentLine.text) {
            return
          }

          const allLineBeforeCurrentLine = state.doc.sliceString(
            0,
            currentLine.from,
          )
          const format = (text: string) => {
            return formatFor(text, 'cm.md').out as string
          }
          const newText = format(allLineBeforeCurrentLine)

          const delta = newText.length - allLineBeforeCurrentLine.length

          const afterCurrentLine = state.doc.sliceString(
            currentLine.to,
            state.doc.length,
          )
          const newAfterCurrentLine = format(afterCurrentLine)

          dispatch({
            changes: {
              from: 0,
              to: state.doc.length,
              insert: newText + newAfterCurrentLine,
            },
            selection: {
              anchor: state.selection.main.anchor + delta,
            },
          })
        })
        .catch(() => {
          // not support wasm
        })
    }
  }
  onMounted(() => {
    if (!refContainer.value) return

    const startState = EditorState.create({
      doc: props.initialDoc,
      extensions: [
        keymap.of([
          {
            key: 'Mod-s',
            run() {
              return false
            },
            preventDefault: true,
          },
          {
            key: 'Enter',
            run(view) {
              // In WYSIWYG mode, insert double newline for paragraph separation
              if (general.setting.renderMode === 'wysiwyg') {
                const { state } = view
                const { from, to } = state.selection.main

                // Insert two newlines (empty line + new line position)
                view.dispatch({
                  changes: { from, to, insert: '\n\n' },
                  selection: { anchor: from + 2 },
                })

                requestAnimationFrame(format)
                return true // Prevent default Enter behavior
              }

              requestAnimationFrame(format)
              return false // Use default Enter behavior in plain mode
            },
          },
          {
            key: 'Mod-/',
            run() {
              general.setting.renderMode =
                general.setting.renderMode === 'wysiwyg' ? 'plain' : 'wysiwyg'
              return true
            },
          },
          {
            key: 'ArrowUp',
            run(view) {
              // In WYSIWYG mode, if cursor is at first line, jump to title input
              if (
                general.setting.renderMode === 'wysiwyg' &&
                onArrowUpAtFirstLine
              ) {
                const { state } = view
                const cursorPos = state.selection.main.head
                const firstLine = state.doc.line(1)

                // Check if cursor is on the first line
                if (cursorPos <= firstLine.to) {
                  onArrowUpAtFirstLine()
                  return true
                }
              }
              return false // Use default ArrowUp behavior
            },
          },
        ]),
        createToolbarKeymapExtension(),
        keymap.of([
          ...defaultKeymap,
          ...historyKeymap,
          ...markdownKeymap,
          ...searchKeymap,
  
... (truncated)
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-20 08:45:12Z)**_

<think><details><summary>Thought Process</summary>
**Exploring arrow key handling extension**
</details></think>

_**Agent (gpt-5.2-codex 2026-01-20 08:45:12Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: d9a69c
Wall time: 0.0522 seconds
Process exited with code 0
Original token count: 885
Output:
import type { DecorationSet, EditorView, ViewUpdate } from '@codemirror/view'

import { Prec, RangeSetBuilder } from '@codemirror/state'
import { cursorLineDown, cursorLineUp } from '@codemirror/commands'
import { Decoration, keymap, ViewPlugin } from '@codemirror/view'

// Decoration to hide paragraph separator empty lines
const hiddenEmptyLineDecoration = Decoration.line({
  class: 'cm-wysiwyg-hidden-empty-line',
})

/**
 * This plugin hides the first empty line after a content line (paragraph separator),
 * but keeps additional consecutive empty lines visible.
 *
 * Logic:
 * - An empty line that follows a non-empty line is a "paragraph separator" -> hide it
 * - An empty line that follows another empty line is "extra spacing" -> show it
 */
function buildDecorations(view: EditorView): DecorationSet {
  const builder = new RangeSetBuilder<Decoration>()
  const doc = view.state.doc

  let prevLineEmpty = true // Treat "before first line" as empty to not hide first empty line

  for (let i = 1; i <= doc.lines; i++) {
    const line = doc.line(i)
    const isCurrentEmpty = line.text.trim() === ''

    if (isCurrentEmpty && !prevLineEmpty) {
      // This empty line follows a content line -> it's a paragraph separator, hide it
      builder.add(line.from, line.from, hiddenEmptyLineDecoration)
    }

    prevLineEmpty = isCurrentEmpty
  }

  return builder.finish()
}

const emptyLinePlugin = ViewPlugin.fromClass(
  class {
    decorations: DecorationSet

    constructor(view: EditorView) {
      this.decorations = buildDecorations(view)
    }

    update(update: ViewUpdate) {
      if (update.docChanged || update.viewportChanged) {
        this.decorations = buildDecorations(update.view)
      }
    }
  },
  {
    decorations: (v) => v.decorations,
  },
)

/**
 * Check if a line is a hidden paragraph separator (empty line after content)
 */
function isHiddenSeparatorLine(view: EditorView, lineNumber: number): boolean {
  const doc = view.state.doc
  if (lineNumber < 1 || lineNumber > doc.lines) return false

  const line = doc.line(lineNumber)
  const isCurrentEmpty = line.text.trim() === ''

  if (!isCurrentEmpty) return false
  if (lineNumber === 1) return false // First line can't be a separator

  const prevLine = doc.line(lineNumber - 1)
  const isPrevEmpty = prevLine.text.trim() === ''

  return !isPrevEmpty // It's a separator if previous line has content
}

/**
 * Custom cursor movement that skips hidden empty lines.
 * First executes the default movement, then checks if we landed on a hidden line.
 * This preserves visual line navigation within wrapped paragraphs.
 */
function moveCursorSkippingHidden(
  view: EditorView,
  direction: 'up' | 'down',
): boolean {
  const moveCommand = direction === 'up' ? cursorLineUp : cursorLineDown

  // Execute default movement first
  const moved = moveCommand(view)
  if (!moved) return false

  // Check if we landed on a hidden separator line
  const pos = view.state.selection.main.head
  const currentLine = view.state.doc.lineAt(pos)

  if (isHiddenSeparatorLine(view, currentLine.number)) {
    // If on a hidden line, move once more to skip it
    return moveCommand(view)
  }

  return true
}

const skipHiddenLineKeymap = Prec.highest(
  keymap.of([
    {
      key: 'ArrowUp',
      run: (view) => moveCursorSkippingHidden(view, 'up'),
    },
    {
      key: 'ArrowDown',
      run: (view) => moveCursorSkippingHidden(view, 'down'),
    },
  ]),
)

export const emptyLineWysiwygExtension = [emptyLinePlugin, skipHiddenLineKeymap]
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-20 08:46:14Z)**_

<think><details><summary>Thought Process</summary>
**Analyzing keymap precedence and order**

The empty line plugin and code block keymaps both use highest precedence, but the extension order likely determines which runs first; currently, the empty line keymap probably runs first and blocks code block keymaps, explaining why code block actions may not trigger when arrow keys are pressed.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-20 08:46:14Z)**_

<think><details><summary>Thought Process</summary>
**Diagnosing skip caused by hidden line and atomic code block**

The emptiness plugin’s arrow down moves cursor over hidden separator lines before code blocks, but because code blocks use atomic replace decorations, the cursor actually jumps past them—causing the skip. This happens because the code block keymap only checks the immediate next line, missing code blocks after hidden lines, so the empty line keymap consumes the event and moves past the block. A key fix is expanding code block detection to consider hidden separator lines before the block start.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-20 08:46:14Z)**_

<tool-use data-tool-type="unknown" data-tool-name="exec_command"><details>
<summary>Tool use: **exec_command**</summary>
```
Chunk ID: 7820b8
Wall time: 0.0521 seconds
Process exited with code 0
Original token count: 65
Output:
src/components/editor/codemirror/wysiwyg-empty-line.ts:107:  keymap.of([
src/components/editor/codemirror/wysiwyg-codeblock.ts:158:        keymap.of([...historyKeymap, indentWithTab]),
src/components/editor/codemirror/wysiwyg-codeblock.ts:487:  keymap.of([
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-20 08:48:18Z)**_

<think><details><summary>Thought Process</summary>
**Analyzing code block navigation logic**

The outer editor uses an `ignoreEvent` widget to block events inside code blocks, relying on inner CodeMirror for arrow keys there. Arrow keys on the outer view trigger moving focus into code blocks by checking adjacent lines, but hidden blank lines may interfere with this detection, potentially causing skipped navigation when moving up or down near code blocks. Next, I'll verify how hidden lines affect keymap triggers and focus transitions.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-20 08:48:18Z)**_

<think><details><summary>Thought Process</summary>
**Diagnosing and planning fix for arrow key skipping over hidden lines near code blocks**

ArrowUp/Down keymaps skip hidden empty lines between blocks, causing code block keymaps not to trigger when expected, so cursor jumps over code blocks. Fix involves enhancing code block keymap to detect and skip hidden separator lines when checking adjacent lines, replicating hidden line logic from emptyLine plugin. This will ensure arrow key navigation properly focuses code blocks despite hidden lines. I'll implement a helper to detect hidden separators and adjust line checks accordingly.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-20 08:48:18Z)**_

<think><details><summary>Thought Process</summary>
**Preparing helper and keymap updates to handle hidden separator lines**

I'm creating a helper to detect hidden empty lines (empty lines preceded by non-empty ones) and updating arrow key handling in the code block keymap to skip these hidden lines when checking adjacent lines for code blocks. This will ensure arrow navigation detects code blocks correctly despite hidden separators without needing to change keymap precedence or alter the emptyLine keymap.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-20 08:48:20Z)**_

<tool-use data-tool-type="write" data-tool-name="apply_patch"><details>
<summary>Tool use: **apply_patch**</summary>
**Update: `src/components/editor/codemirror/wysiwyg-codeblock.ts`**

```diff
@@
 const isCursorInCodeBlock = (state: EditorState, block: CodeBlock): boolean => {
   const { from, to } = state.selection.main
   return from <= block.endTo && to >= block.startFrom
 }
 
+const isHiddenSeparatorLine = (
+  state: EditorState,
+  lineNumber: number,
+): boolean => {
+  const doc = state.doc
+  if (lineNumber < 1 || lineNumber > doc.lines) return false
+  const line = doc.line(lineNumber)
+  if (line.text.trim() !== '') return false
+  if (lineNumber === 1) return false
+  const prevLine = doc.line(lineNumber - 1)
+  return prevLine.text.trim() !== ''
+}
+
 // Detect dark mode
 const isDarkMode = (): boolean => {
   return document.documentElement.classList.contains('dark')
 }
@@
         if (!state.selection.main.empty) return false
 
         const blocks = findCodeBlocks(state)
         if (getBlockContainingSelection(state, blocks)) return false
 
         const currentLine = state.doc.lineAt(state.selection.main.head)
-        const nextLineNumber = currentLine.number + 1
+        let nextLineNumber = currentLine.number + 1
         if (nextLineNumber > state.doc.lines) return false
 
+        if (isHiddenSeparatorLine(state, nextLineNumber)) {
+          nextLineNumber += 1
+        }
+        if (nextLineNumber > state.doc.lines) return false
+
         const block = blocks.find((item) => item.startLine === nextLineNumber)
         if (!block) return false
@@
         if (!state.selection.main.empty) return false
 
         const blocks = findCodeBlocks(state)
         if (getBlockContainingSelection(state, blocks)) return false
 
         const currentLine = state.doc.lineAt(state.selection.main.head)
-        const prevLineNumber = currentLine.number - 1
+        let prevLineNumber = currentLine.number - 1
         if (prevLineNumber < 1) return false
 
+        if (isHiddenSeparatorLine(state, prevLineNumber)) {
+          prevLineNumber -= 1
+        }
+        if (prevLineNumber < 1) return false
+
         const block = blocks.find((item) => item.endLine === prevLineNumber)
         if (!block) return false
```
</details></tool-use>

_**Agent (gpt-5.2-codex 2026-01-20 08:48:41Z)**_

<think><details><summary>Thought Process</summary>
**Explaining hidden line skip fix**

In `src/components/editor/codemirror/wysiwyg-codeblock.ts`, the arrow navigation didn’t handle hidden empty separator lines inserted by the `wysiwyg-empty-line` extension. Because arrow key logic only checked adjacent lines and didn’t skip hidden separators, it caused the editor to jump over code blocks unexpectedly. The fix adds detection of these hidden separator lines in the code block keymap to correctly prevent skipping them. Next, I'll suggest testing arrow navigation across paragraphs and code blocks with blank lines and verifying extra blank lines remain navigable—note tests were not run yet.
</details></think>

_**Agent (gpt-5.2-codex 2026-01-20 08:48:41Z)**_

<think><details><summary>Thought Process</summary>
**Providing final fix explanation in Chinese**

原因是 `wysiwyg-empty-line` 会在段落分隔的空行上拦截 ArrowUp/Down 并跳过隐藏空行，但 `codeBlockWysiwygKeymap` 只判断紧邻行是否是 ``` 起始/结束行；当中间有被隐藏的空行时，它不会触发，随后 cursorLineUp/Down 会跨过被 replace 为 atomic 的 code block 范围，所以看起来直接跳到下一个块。

已在 `src/components/editor/codemirror/wysiwyg-codeblock.ts` 增加隐藏分隔行判断，ArrowUp/Down 会先跳过隐藏空行再判断是否进入/退出 code block。

建议验证：
1. 段落-空行-代码块-空行-段落，ArrowUp/Down 是否进入代码块。  
2. 连续两行空行时，是否仍会停在可见空行而不是直接进代码块。

未运行测试。
</details></think>

_**Agent (gpt-5.2-codex 2026-01-20 08:48:42Z)**_

原因是 `wysiwyg-empty-line` 会拦截 ArrowUp/Down 并跳过被隐藏的段落分隔空行，而 `codeBlockWysiwygKeymap` 只判断“紧邻行”是否是 ``` 起始/结束行；当中间隔着隐藏空行时它不会触发，后续的 `cursorLineUp/Down` 又会跨过被 replace 成原子范围的 code block，所以看起来直接跳到下一个块。

我在 `src/components/editor/codemirror/wysiwyg-codeblock.ts` 增加了隐藏分隔行判断，ArrowUp/Down 会先跳过隐藏空行再判断是否进入/退出 code block，从而避免被跳过。未跑测试。

可以验证一下：
1. 段落-空行-代码块-空行-段落，ArrowUp/Down 是否进入代码块。
2. 连续两行空行时，是否仍会停在可见空行而不是直接进代码块。
